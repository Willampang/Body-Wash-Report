// ===== CONFIGURATION =====
const CONFIG = {
  SHOPIFY_STORE: 'z14sj1-i5.myshopify.com',
  ACCESS_TOKEN: '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',
  API_VERSION: '2024-01',
  EMAIL_TEMPLATE: {
    subject: '请填写出生信息 - Birth Information Required',
    fromName: 'Mandarin by Louis Loh'
  },
  WALLET_TRIGGERS: ['富豪款', '丰盛款', '吸金款', '带财款', '聚财款']
};

const GOLDEN_CARD_VARIANTS = {
  "乾宫": { variant_id: 46719017943206, price: "0.00", title: "乾宫" },
  "坎宫": { variant_id: 46719017844902, price: "0.00", title: "坎宫" },
  "艮宫": { variant_id: 46719017779366, price: "0.00", title: "艮宫" },
  "震宫": { variant_id: 46719017681062, price: "0.00", title: "震宫" },
  "巽宫": { variant_id: 46719017615526, price: "0.00", title: "巽宫" },
  "离宫": { variant_id: 46719017517222, price: "0.00", title: "离宫" },
  "坤宫": { variant_id: 46719017451686, price: "0.00", title: "坤宫" },
  "兑宫": { variant_id: 46719017353382, price: "0.00", title: "兑宫" }
};

// ===== QIMEN DUNJIA CALCULATOR =====
class QiMenDunJiaCalculator {
  constructor() {
    this.tianGan = ['甲','乙','丙','丁','戊','己','庚','辛','壬','癸'];
    this.diZhi = ['子','丑','寅','卯','辰','巳','午','未','申','酉','戌','亥'];
    this.baMen = ['休门','死门','伤门','杜门','中宫','开门','惊门','生门','景门'];
    this.jiuXing = ['天蓬','天芮','天冲','天辅','天禽','天心','天柱','天任','天英'];
    this.jiuShen = ['直符','螣蛇','太阴','六合','白虎','玄武','九地','九天','太常'];
    this.jiuGong = ['乾六宫','坎一宫','艮八宫','震三宫','中五宫','兑七宫','巽四宫','离九宫','坤二宫'];
    this.jieQiJuShu = {
      '冬至':1,'小寒':1,'大寒':1,'立春':2,'雨水':2,'惊蛰':2,'春分':3,'清明':3,'谷雨':3,
      '立夏':4,'小满':4,'芒种':4,'夏至':5,'小暑':5,'大暑':5,'立秋':6,'处暑':6,'白露':6,
      '秋分':7,'寒露':7,'霜降':7,'立冬':8,'小雪':8,'大雪':8
    };
    this.goldCardMap = {
      "乾": "乾宫","坎": "坎宫","艮": "艮宫","震": "震宫",
      "巽": "巽宫","离": "离宫","坤": "坤宫","兑": "兑宫"
    };
  }

  calculateQiMen(year, month, day, hour, minute = 0) {
    try {
      if (!this.isValidDate(year, month, day)) throw new Error(`Invalid date: ${year}-${month}-${day}`);
      const basicInfo = this.getBasicInfo(year, month, day, hour, minute);
      const juShu = this.getJuShu(basicInfo.jieQi, basicInfo.isYangDun);
      const zhiFuZhiShi = this.getZhiFuZhiShi(basicInfo.jiaZi, juShu);
      const jiuGongJu = this.arrangeJiuGong(juShu, zhiFuZhiShi);
      const goldCard = this.getGoldCard(jiuGongJu);
      return { goldCard: goldCard };
    } catch (error) {
      return { goldCard: null, error: error.message };
    }
  }

  isValidDate(year, month, day) {
    if (year < 1900 || year > 2100) return false;
    if (month < 1 || month > 12) return false;
    if (day < 1 || day > 31) return false;
    const date = new Date(year, month - 1, day);
    return date.getFullYear() === year && date.getMonth() === month - 1 && date.getDate() === day;
  }

  getBasicInfo(year, month, day, hour, minute) {
    const date = new Date(year, month - 1, day, hour, minute);
    const jieQi = this.getJieQi(month, day);
    const isYangDun = this.isYangDun(jieQi);
    const jiaZi = this.getJiaZi(year, month, day, hour);
    return { date, jieQi, isYangDun, jiaZi };
  }

  getJiaZi(year, month, day, hour) {
    const baseDate = new Date(1900, 0, 31);
    const currentDate = new Date(year, month - 1, day);
    const daysDiff = Math.floor((currentDate.getTime() - baseDate.getTime()) / (1000 * 60 * 60 * 24));
    const chineseHour = Math.floor((hour + 1) / 2) % 12;
    const totalUnits = daysDiff * 12 + chineseHour;
    return ((totalUnits % 60) + 60) % 60;
  }

  getJieQi(month, day) {
    const jieQiMap = {
      1: day < 20 ? '小寒' : '大寒', 2: day < 19 ? '大寒' : '立春',
      3: day < 21 ? '惊蛰' : '春分', 4: day < 20 ? '清明' : '谷雨',
      5: day < 21 ? '立夏' : '小满', 6: day < 21 ? '芒种' : '夏至',
      7: day < 23 ? '小暑' : '大暑', 8: day < 23 ? '立秋' : '处暑',
      9: day < 23 ? '白露' : '秋分', 10: day < 23 ? '寒露' : '霜降',
      11: day < 22 ? '立冬' : '小雪', 12: day < 22 ? '大雪' : '冬至'
    };
    return jieQiMap[month] || '春分';
  }

  isYangDun(jieQi) {
    return ['冬至','小寒','大寒','立春','雨水','惊蛰','春分','清明','谷雨'].includes(jieQi);
  }

  getJuShu(jieQi, isYangDun) {
    let ju = this.jieQiJuShu[jieQi] || 1;
    return isYangDun ? ju : (9 - ju + 1);
  }

  getZhiFuZhiShi(jiaZi, juShu) {
    return { 
      zhiFu: this.jiuShen[jiaZi % this.jiuShen.length], 
      zhiShi: this.baMen[jiaZi % this.baMen.length] 
    };
  }

  arrangeJiuGong(juShu) {
    return this.jiuGong.map((gong, i) => {
      const gongName = this.extractGongName(gong);
      return {
        gongWei: gong,
        men: this.baMen[(i + juShu - 1) % this.baMen.length],
        xing: this.jiuXing[(i + juShu - 1) % this.jiuXing.length],
        shen: this.jiuShen[(i + juShu - 1) % this.jiuShen.length],
        gongName: gongName,
        goldCard: this.goldCardMap[gongName] || ""
      };
    });
  }

  extractGongName(gong) {
    const map = { 
      '乾六宫':'乾','坎一宫':'坎','艮八宫':'艮','震三宫':'震',
      '中五宫':'中','兑七宫':'兑','巽四宫':'巽','离九宫':'离','坤二宫':'坤' 
    };
    return map[gong] || gong.charAt(0);
  }

  getGoldCard(jiuGongJu) {
    const zhiFuGong = jiuGongJu.find(g => g.shen === "直符");
    return zhiFuGong ? zhiFuGong.goldCard : null;
  }
}

// ===== HELPER FUNCTIONS =====
function parseTimeInput(birthHour) {
  if (!birthHour) return { hour: 0, minute: 0 };
  
  try {
    const hourStr = String(birthHour).trim();
    let h = 0, m = 0;

    if (hourStr.match(/^\d{1,2}:\d{2}:\d{2}$/)) {
      const parts = hourStr.split(":");
      h = parseInt(parts[0], 10) || 0;
      m = parseInt(parts[1], 10) || 0;
      return { hour: Math.max(0, Math.min(23, h)), minute: Math.max(0, Math.min(59, m)) };
    }

    if (hourStr.match(/^\d{1,2}:\d{2}$/)) {
      const parts = hourStr.split(":");
      h = parseInt(parts[0], 10) || 0;
      m = parseInt(parts[1], 10) || 0;
      return { hour: Math.max(0, Math.min(23, h)), minute: Math.max(0, Math.min(59, m)) };
    }

    if (hourStr.match(/^\d{1,2}$/)) {
      h = parseInt(hourStr, 10) || 0;
      return { hour: Math.max(0, Math.min(23, h)), minute: 0 };
    }

    let isPM = /pm|下午/i.test(hourStr);
    let isAM = /am|上午/i.test(hourStr);
    const cleanHour = hourStr.replace(/[apm\.上下午\s]/gi, '');
    h = parseInt(cleanHour, 10) || 0;
    
    if (isPM && h < 12) h += 12;
    if (isAM && h === 12) h = 0;

    return { hour: Math.max(0, Math.min(23, h)), minute: 0 };
  } catch (error) {
    return { hour: 0, minute: 0 };
  }
}

function parseFlexibleBirthday(birthdayInput) {
  if (!birthdayInput) return null;
  
  try {
    if (birthdayInput instanceof Date) {
      return birthdayInput;
    }
    
    const dateStr = String(birthdayInput).trim();

    // Google Forms format: "12/06/2001" or "6/12/2001"
    const ddmmyyyyMatch = dateStr.match(/^(\d{1,2})[\/\-\.](\d{1,2})[\/\-\.](\d{4})$/);
    if (ddmmyyyyMatch) {
      const day = parseInt(ddmmyyyyMatch[1], 10);
      const month = parseInt(ddmmyyyyMatch[2], 10);
      const year = parseInt(ddmmyyyyMatch[3], 10);
      
      if (year < 1900 || year > 2100 || month < 1 || month > 12 || day < 1 || day > 31) {
        return null;
      }
      
      const date = new Date(year, month - 1, day);
      if (date.getFullYear() !== year || date.getMonth() !== month - 1 || date.getDate() !== day) {
        return null;
      }
      
      return date;
    }

    // YYYY-MM-DD or YYYY/MM/DD format
    const yyyymmddMatch = dateStr.match(/^(\d{4})[\/\-\.](\d{1,2})[\/\-\.](\d{1,2})$/);
    if (yyyymmddMatch) {
      const year = parseInt(yyyymmddMatch[1], 10);
      const month = parseInt(yyyymmddMatch[2], 10);
      const day = parseInt(yyyymmddMatch[3], 10);
      
      if (year < 1900 || year > 2100 || month < 1 || month > 12 || day < 1 || day > 31) {
        return null;
      }
      
      const date = new Date(year, month - 1, day);
      if (date.getFullYear() !== year || date.getMonth() !== month - 1 || date.getDate() !== day) {
        return null;
      }
      
      return date;
    }

    // Try to parse as Date object directly (Google Forms sometimes returns date strings)
    const parsedDate = new Date(birthdayInput);
    if (!isNaN(parsedDate.getTime())) {
      return parsedDate;
    }

    return null;
    
  } catch (error) {
    return null;
  }
}

function calculateQimenForBirthday(birthday, birthHour) {
  const date = parseFlexibleBirthday(birthday);
  if (!date) return null;
  
  const timeResult = parseTimeInput(birthHour);
  const h = timeResult.hour;
  const m = timeResult.minute;
  
  try {
    const calc = new QiMenDunJiaCalculator();
    const result = calc.calculateQiMen(
      date.getFullYear(), 
      date.getMonth() + 1, 
      date.getDate(), 
      h, 
      m
    );
    
    return result.goldCard;
  } catch (error) {
    return null;
  }
}

// ===== SHOPIFY HELPER FUNCTIONS =====
function getOrderIdFromName(orderName) {
  try {
    const cleanName = orderName.trim();
    const searchUrl = `https://${CONFIG.SHOPIFY_STORE}/admin/api/${CONFIG.API_VERSION}/orders.json?name=${encodeURIComponent(cleanName)}&status=any&limit=1`;
    const options = {
      method: 'GET',
      headers: {
        'X-Shopify-Access-Token': CONFIG.ACCESS_TOKEN,
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      muteHttpExceptions: true
    };
    
    const resp = UrlFetchApp.fetch(searchUrl, options);
    if (resp.getResponseCode() !== 200) return null;
    
    const orders = JSON.parse(resp.getContentText()).orders;
    if (orders && orders.length > 0) {
      return orders[0].id;
    }
    
    return null;
  } catch (e) {
    return null;
  }
}

function addGoldenCardToOrder(orderIdentifier, goldenCard) {
  const variantInfo = GOLDEN_CARD_VARIANTS[goldenCard];
  if (!variantInfo) {
    return { success: false, error: "Unknown golden card: " + goldenCard };
  }
  
  try {
    let numericOrderId = orderIdentifier;
    
    const idStr = String(orderIdentifier);
    if (idStr.includes('#') || idStr.includes('W') || parseInt(idStr) < 1000000) {
      numericOrderId = getOrderIdFromName(orderIdentifier);
      if (!numericOrderId) {
        return { success: false, error: `Could not find order: ${orderIdentifier}` };
      }
    }
    
    const getOrderUrl = `https://${CONFIG.SHOPIFY_STORE}/admin/api/${CONFIG.API_VERSION}/orders/${numericOrderId}.json`;
    const getOptions = {
      method: 'GET',
      headers: {
        'X-Shopify-Access-Token': CONFIG.ACCESS_TOKEN,
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      muteHttpExceptions: true
    };
    
    const getResp = UrlFetchApp.fetch(getOrderUrl, getOptions);
    if (getResp.getResponseCode() !== 200) {
      return { success: false, error: "Could not fetch order: " + getResp.getContentText() };
    }
    
    const order = JSON.parse(getResp.getContentText()).order;
    
    const existingGoldenCard = order.line_items.find(item => 
      item.variant_id === parseInt(variantInfo.variant_id)
    );
    
    if (existingGoldenCard) {
      return { 
        success: true, 
        skipped: true,
        orderName: order.name,
        response: `Order ${order.name} already has ${goldenCard}` 
      };
    }
    
    const graphqlUrl = `https://${CONFIG.SHOPIFY_STORE}/admin/api/${CONFIG.API_VERSION}/graphql.json`;
    
    const beginEditMutation = `
      mutation orderEditBegin($id: ID!) {
        orderEditBegin(id: $id) {
          calculatedOrder {
            id
          }
          userErrors {
            field
            message
          }
        }
      }
    `;
    
    const beginEditVariables = {
      id: `gid://shopify/Order/${numericOrderId}`
    };
    
    const beginOptions = {
      method: 'POST',
      headers: {
        'X-Shopify-Access-Token': CONFIG.ACCESS_TOKEN,
        'Content-Type': 'application/json'
      },
      payload: JSON.stringify({
        query: beginEditMutation,
        variables: beginEditVariables
      }),
      muteHttpExceptions: true
    };
    
    const beginResp = UrlFetchApp.fetch(graphqlUrl, beginOptions);
    const beginResult = JSON.parse(beginResp.getContentText());
    
    if (beginResult.errors || beginResult.data.orderEditBegin.userErrors.length > 0) {
      const errors = beginResult.errors || beginResult.data.orderEditBegin.userErrors;
      return { success: false, error: `Failed to begin edit: ${JSON.stringify(errors)}` };
    }
    
    const calculatedOrderId = beginResult.data.orderEditBegin.calculatedOrder.id;
    
    const addItemMutation = `
      mutation orderEditAddVariant($id: ID!, $variantId: ID!, $quantity: Int!) {
        orderEditAddVariant(id: $id, variantId: $variantId, quantity: $quantity, allowDuplicates: true) {
          calculatedOrder {
            id
          }
          calculatedLineItem {
            id
          }
          userErrors {
            field
            message
          }
        }
      }
    `;
    
    const addItemVariables = {
      id: calculatedOrderId,
      variantId: `gid://shopify/ProductVariant/${variantInfo.variant_id}`,
      quantity: 1
    };
    
    const addItemOptions = {
      method: 'POST',
      headers: {
        'X-Shopify-Access-Token': CONFIG.ACCESS_TOKEN,
        'Content-Type': 'application/json'
      },
      payload: JSON.stringify({
        query: addItemMutation,
        variables: addItemVariables
      }),
      muteHttpExceptions: true
    };
    
    const addItemResp = UrlFetchApp.fetch(graphqlUrl, addItemOptions);
    const addItemResult = JSON.parse(addItemResp.getContentText());
    
    if (addItemResult.errors || addItemResult.data.orderEditAddVariant.userErrors.length > 0) {
      const errors = addItemResult.errors || addItemResult.data.orderEditAddVariant.userErrors;
      return { success: false, error: `Failed to add item: ${JSON.stringify(errors)}` };
    }
    
    const lineItemId = addItemResult.data.orderEditAddVariant.calculatedLineItem.id;
    
    const setDiscountMutation = `
      mutation orderEditSetQuantity($id: ID!, $lineItemId: ID!, $quantity: Int!, $restock: Boolean) {
        orderEditSetQuantity(id: $id, lineItemId: $lineItemId, quantity: $quantity, restock: $restock) {
          calculatedOrder {
            id
          }
          calculatedLineItem {
            id
            custom
          }
          userErrors {
            field
            message
          }
        }
      }
    `;
    
    const setDiscountVariables = {
      id: calculatedOrderId,
      lineItemId: lineItemId,
      quantity: 1,
      restock: false
    };
    
    const setDiscountOptions = {
      method: 'POST',
      headers: {
        'X-Shopify-Access-Token': CONFIG.ACCESS_TOKEN,
        'Content-Type': 'application/json'
      },
      payload: JSON.stringify({
        query: setDiscountMutation,
        variables: setDiscountVariables
      }),
      muteHttpExceptions: true
    };
    
    UrlFetchApp.fetch(graphqlUrl, setDiscountOptions);
    
    const commitMutation = `
      mutation orderEditCommit($id: ID!, $notifyCustomer: Boolean, $staffNote: String) {
        orderEditCommit(id: $id, notifyCustomer: $notifyCustomer, staffNote: $staffNote) {
          order {
            id
          }
          userErrors {
            field
            message
          }
        }
      }
    `;
    
    const commitVariables = {
      id: calculatedOrderId,
      notifyCustomer: false,
      staffNote: `Golden card ${goldenCard} added automatically (complimentary)`
    };
    
    const commitOptions = {
      method: 'POST',
      headers: {
        'X-Shopify-Access-Token': CONFIG.ACCESS_TOKEN,
        'Content-Type': 'application/json'
      },
      payload: JSON.stringify({
        query: commitMutation,
        variables: commitVariables
      }),
      muteHttpExceptions: true
    };
    
    const commitResp = UrlFetchApp.fetch(graphqlUrl, commitOptions);
    const commitResult = JSON.parse(commitResp.getContentText());
    
    if (commitResult.errors || commitResult.data.orderEditCommit.userErrors.length > 0) {
      const errors = commitResult.errors || commitResult.data.orderEditCommit.userErrors;
      return { success: false, error: `Failed to commit: ${JSON.stringify(errors)}` };
    }
    
    return { 
      success: true, 
      orderId: numericOrderId,
      orderName: order.name,
      response: `Added ${goldenCard} to order ${order.name}` 
    };
    
  } catch (e) {
    return { success: false, error: e.toString() };
  }
}

// ===== CHECK IF ORDER ALREADY PROCESSED =====
function isOrderProcessed(orderId) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ordersSheet = ss.getSheetByName("Orders");
    
    if (!ordersSheet) return false;
    
    const data = ordersSheet.getDataRange().getValues();
    
    for (let i = 1; i < data.length; i++) {
      if (String(data[i][0]) === String(orderId)) {
        return true;
      }
    }
    
    return false;
  } catch (e) {
    return false;
  }
}

// ===== CHECK IF EMAIL ALREADY SENT =====
function isEmailAlreadySent(orderId) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ordersSheet = ss.getSheetByName("Orders");
    
    if (!ordersSheet) return false;
    
    const data = ordersSheet.getDataRange().getValues();
    
    for (let i = 1; i < data.length; i++) {
      if (String(data[i][0]) === String(orderId)) {
        const emailStatus = data[i][7];
        return emailStatus === "YES";
      }
    }
    
    return false;
  } catch (e) {
    return false;
  }
}

// ===== CHECK WALLET TYPES =====
function checkWalletTypes(orderData) {
  let totalWalletQty = 0;
  let walletTypes = [];
  
  orderData.line_items.forEach(item => {
    const title = (item.title || '').trim();
    const variant = (item.variant_title || '').trim();
    
    CONFIG.WALLET_TRIGGERS.forEach(walletType => {
      if (title.includes(walletType) || variant.includes(walletType)) {
        totalWalletQty += item.quantity;
        walletTypes.push(`${walletType} x${item.quantity}`);
      }
    });
  });
  
  return {
    hasTriggerWallets: totalWalletQty > 0,
    totalQty: totalWalletQty,
    walletTypes: walletTypes
  };
}

// ===== CREATE FORM WITH DATE & TIME FIELDS =====
function createDynamicForm(orderName, customerName, customerEmail, quantity, walletTypes) {
  try {
    const form = FormApp.create(`Birth Info - ${orderName}`);
    
    form.setTitle(`钱包出生信息表格 Wallet Birth Information Form`);
    
    form.setDescription(
      `===============================================\n` +
      `订单号 Order: ${orderName}\n` +
      `客户 Customer: ${customerName}\n` +
      `邮箱 Email: ${customerEmail}\n` +
      `===============================================\n\n` +
      `您购买的钱包 Wallets Purchased:\n` +
      walletTypes.map(w => `  • ${w}`).join('\n') + `\n\n` +
      `请为 ${quantity} 个钱包填写出生信息\n` +
      `Please fill birth information for ${quantity} wallet(s)\n`
    );
    
    form.addTextItem()
      .setTitle('订单号 Order Name (自动填写)')
      .setHelpText('请勿修改 Do not modify')
      .setRequired(true);
    
    form.addTextItem()
      .setTitle('客户邮箱 Customer Email (自动填写)')
      .setHelpText('请勿修改 Do not modify')
      .setRequired(true);
    
    for (let i = 1; i <= quantity; i++) {
      form.addPageBreakItem()
        .setTitle(`钱包 Wallet ${i} / ${quantity}`)
        .setHelpText(`请填写第 ${i} 个钱包使用者的信息`);
      
      form.addTextItem()
        .setTitle(`钱包 ${i} - 姓名 Name`)
        .setHelpText('使用此钱包的人的全名 Full name')
        .setRequired(true);
      
      form.addDateItem()
        .setTitle(`钱包 ${i} - 出生日期 Birthday`)
        .setHelpText('请选择出生日期 Please select birth date')
        .setRequired(true);
      
      form.addTimeItem()
        .setTitle(`钱包 ${i} - 出生时间 Birth Time`)
        .setHelpText('请选择出生时间 (24小时制) Please select birth time (24-hour)')
        .setRequired(true);
    }
    
    form.addPageBreakItem()
      .setTitle('确认提交 Confirm & Submit')
      .setHelpText('请检查所有信息后提交 Please review before submitting');
    
    const formId = form.getId();
    const baseUrl = form.getPublishedUrl();
    const items = form.getItems();
    
    const orderEntryId = items[0].getId();
    const emailEntryId = items[1].getId();
    
    const prefillUrl = baseUrl + 
      `?entry.${orderEntryId}=${encodeURIComponent(orderName)}` +
      `&entry.${emailEntryId}=${encodeURIComponent(customerEmail)}`;
    
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    form.setDestination(FormApp.DestinationType.SPREADSHEET, ss.getId());
    
    return {
      success: true,
      formId: formId,
      formUrl: prefillUrl,
      editUrl: form.getEditUrl()
    };
    
  } catch (e) {
    return {
      success: false,
      error: e.toString()
    };
  }
}

// ===== SEND EMAIL =====
function sendFormEmail(customerEmail, customerName, formUrl, orderName, walletTypes) {
  try {
    const subject = CONFIG.EMAIL_TEMPLATE.subject;
    
    const body = `
亲爱的 ${customerName},

感谢您的购买!

订单号 Order: ${orderName}

您购买的钱包 Wallets purchased:
${walletTypes.map(w => `  • ${w}`).join('\n')}

请点击以下链接填写出生信息表格:
Please click the link below to fill the form:

${formUrl}

此信息将用于计算您的专属金卡(基于奇门遁甲).
This information will be used to calculate your personalized golden cards.

如有疑问请联系客服.
For questions please contact customer service.

此致,
${CONFIG.EMAIL_TEMPLATE.fromName}

---
此邮件由系统自动发送
This email is sent automatically
    `.trim();
    
    MailApp.sendEmail({
      to: customerEmail,
      subject: subject,
      body: body,
      name: CONFIG.EMAIL_TEMPLATE.fromName
    });
    
    return { success: true };
    
  } catch (e) {
    return { success: false, error: e.toString() };
  }
}

// ===== PROCESS ORDER =====
function processNewOrder(orderData) {
  try {
    const orderId = orderData.id;
    const orderName = orderData.name || orderData.order_number || `#${orderId}`;
    
    let customerName = "Customer";
    if (orderData.customer) {
      const firstName = orderData.customer.first_name || "";
      const lastName = orderData.customer.last_name || "";
      customerName = `${firstName} ${lastName}`.trim() || orderData.customer.email || "Customer";
    }
    
    const email = orderData.customer ? orderData.customer.email : "";
    
    if (!email) {
      return { success: false, error: "No customer email" };
    }
    
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    let ordersSheet = ss.getSheetByName("Orders");
    
    if (!ordersSheet) {
      ordersSheet = ss.insertSheet("Orders");
      ordersSheet.appendRow([
        "Order ID", "Order Name", "Customer Name", "Email", 
        "Wallet Types", "Qty", "Form URL", "Form Sent", "Status", "Golden Cards", "Timestamp"
      ]);
      const headerRange = ordersSheet.getRange(1, 1, 1, 11);
      headerRange.setFontWeight("bold");
      headerRange.setBackground("#4285f4");
      headerRange.setFontColor("#ffffff");
    }
    
    // CRITICAL: Check duplicate BEFORE any slow operations
    const lock = LockService.getScriptLock();
    try {
      lock.waitLock(30000); // Wait up to 30 seconds for lock
      
      if (isOrderProcessed(orderId)) {
        return { 
          success: false, 
          error: "Duplicate - already processed",
          duplicate: true
        };
      }
      
      // IMMEDIATELY write placeholder row to claim this order
      ordersSheet.appendRow([
        orderId,
        orderName,
        customerName,
        email,
        "Processing...",
        0,
        "Generating...",
        "PENDING",
        "Processing",
        "",
        new Date()
      ]);
      
    } finally {
      lock.releaseLock();
    }
    
    const walletCheck = checkWalletTypes(orderData);
    
    if (!walletCheck.hasTriggerWallets) {
      // Update the row to mark as skipped
      updateOrderRow(orderId, {
        walletTypes: "N/A",
        status: "Skipped - No trigger wallets",
        formSent: "N/A"
      });
      return { 
        success: false, 
        error: "No trigger wallets",
        skipped: true 
      };
    }
    
    const formResult = createDynamicForm(
      orderName, 
      customerName, 
      email, 
      walletCheck.totalQty,
      walletCheck.walletTypes
    );
    
    if (!formResult.success) {
      updateOrderRow(orderId, {
        walletTypes: walletCheck.walletTypes.join(' | '),
        qty: walletCheck.totalQty,
        status: "Failed - Form creation error",
        formSent: "FAILED"
      });
      return { success: false, error: "Form creation failed: " + formResult.error };
    }
    
    const emailResult = sendFormEmail(
      email, 
      customerName, 
      formResult.formUrl, 
      orderName,
      walletCheck.walletTypes
    );
    
    // Update the row with final information
    updateOrderRow(orderId, {
      walletTypes: walletCheck.walletTypes.join(' | '),
      qty: walletCheck.totalQty,
      formUrl: formResult.formUrl,
      formSent: emailResult.success ? "YES" : "FAILED",
      status: emailResult.success ? "Pending Form Submission" : "Email Failed"
    });
    
    return {
      success: true,
      orderName: orderName,
      formUrl: formResult.formUrl,
      emailSent: emailResult.success
    };
    
  } catch (e) {
    return { success: false, error: e.toString() };
  }
}

// ===== UPDATE ORDER ROW =====
function updateOrderRow(orderId, updates) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ordersSheet = ss.getSheetByName("Orders");
    
    if (!ordersSheet) return;
    
    const data = ordersSheet.getDataRange().getValues();
    
    for (let i = 1; i < data.length; i++) {
      if (String(data[i][0]) === String(orderId)) {
        const row = i + 1;
        
        if (updates.walletTypes !== undefined) {
          ordersSheet.getRange(row, 5).setValue(updates.walletTypes);
        }
        if (updates.qty !== undefined) {
          ordersSheet.getRange(row, 6).setValue(updates.qty);
        }
        if (updates.formUrl !== undefined) {
          ordersSheet.getRange(row, 7).setValue(updates.formUrl);
        }
        if (updates.formSent !== undefined) {
          ordersSheet.getRange(row, 8).setValue(updates.formSent);
        }
        if (updates.status !== undefined) {
          ordersSheet.getRange(row, 9).setValue(updates.status);
        }
        if (updates.goldenCards !== undefined) {
          ordersSheet.getRange(row, 10).setValue(updates.goldenCards);
        }
        
        return;
      }
    }
    
  } catch (error) {
    // Silent fail
  }
}

// ===== WEB APP HANDLERS =====
function doGet(e) {
  return ContentService.createTextOutput(
    JSON.stringify({
      status: "OK",
      message: "Wallet Birth Info System Running",
      timestamp: new Date().toISOString()
    })
  ).setMimeType(ContentService.MimeType.JSON);
}

function doPost(e) {
  try {
    if (!e || !e.postData || !e.postData.contents) {
      return ContentService.createTextOutput(
        JSON.stringify({ success: false, error: "No data" })
      ).setMimeType(ContentService.MimeType.JSON);
    }
    
    const orderData = JSON.parse(e.postData.contents);
    const result = processNewOrder(orderData);
    
    return ContentService.createTextOutput(
      JSON.stringify(result)
    ).setMimeType(ContentService.MimeType.JSON);
    
  } catch (error) {
    return ContentService.createTextOutput(
      JSON.stringify({ success: false, error: error.toString() })
    ).setMimeType(ContentService.MimeType.JSON);
  }
}

// ===== FORM SUBMISSION HANDLER =====
function onFormSubmit(e) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    let responsesSheet = ss.getSheetByName("Form Responses");

    if (!responsesSheet) {
      responsesSheet = ss.insertSheet("Form Responses");
      responsesSheet.appendRow([
        "Submission Time", 
        "Order Name", 
        "Customer Email", 
        "Wallet Number", 
        "Person Name",
        "Birthday", 
        "Birth Time", 
        "Golden Card Calculated",
        "Added to Shopify", 
        "Processing Timestamp"
      ]);
      
      const headerRange = responsesSheet.getRange(1, 1, 1, 10);
      headerRange.setFontWeight("bold");
      headerRange.setBackground("#34a853");
      headerRange.setFontColor("#ffffff");
      responsesSheet.setFrozenRows(1);
    }

    const response = e.values;
    const submissionTime = response[0];
    const orderName = response[1];
    const customerEmail = response[2];

    let goldenCardsAdded = [];
    let totalWallets = 0;

    for (let i = 3; i < response.length; i += 3) {
      const walletNumber = Math.floor((i - 3) / 3) + 1;
      const personName = response[i] || "";
      const birthday = response[i + 1] || "";
      const birthTime = response[i + 2] || "";

      if (!birthday) {
        continue;
      }

      totalWallets++;

      const goldenCard = calculateQimenForBirthday(birthday, birthTime);

      let shopifyStatus = "";
      if (goldenCard) {
        const addResult = addGoldenCardToOrder(orderName, goldenCard);
        
        if (addResult.success) {
          if (addResult.skipped) {
            shopifyStatus = `SKIPPED (Already has ${goldenCard})`;
          } else {
            shopifyStatus = `✓ ADDED: ${goldenCard}`;
            goldenCardsAdded.push(goldenCard);
          }
        } else {
          shopifyStatus = `✗ FAILED: ${addResult.error}`;
        }
      } else {
        shopifyStatus = "✗ CALCULATION FAILED";
      }

      responsesSheet.appendRow([
        submissionTime,
        orderName,
        customerEmail,
        `Wallet ${walletNumber}`,
        personName,
        birthday,
        birthTime,
        goldenCard || "N/A",
        shopifyStatus,
        new Date()
      ]);
    }

    if (totalWallets > 0) {
      const statusMessage = goldenCardsAdded.length > 0 
        ? `✓ Completed (${goldenCardsAdded.length}/${totalWallets} cards added)`
        : "⚠️ Form Submitted (No cards added)";
      
      const cardsString = goldenCardsAdded.length > 0 
        ? goldenCardsAdded.join(", ") 
        : "None";
      
      updateOrderStatus(orderName, statusMessage, cardsString);
    }
    
  } catch (error) {
    try {
      const ss = SpreadsheetApp.getActiveSpreadsheet();
      let errorSheet = ss.getSheetByName("Error Log");
      if (!errorSheet) {
        errorSheet = ss.insertSheet("Error Log");
        errorSheet.appendRow(["Timestamp", "Error Type", "Error Message", "Stack Trace"]);
        errorSheet.getRange(1, 1, 1, 4).setFontWeight("bold").setBackground("#ea4335").setFontColor("#ffffff");
      }
      errorSheet.appendRow([
        new Date(),
        "Form Submission Error",
        error.toString(),
        error.stack
      ]);
    } catch (logError) {
      // Silent fail
    }
  }
}

// ===== UPDATE ORDER STATUS IN ORDERS SHEET =====
function updateOrderStatus(orderName, status, goldenCards) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ordersSheet = ss.getSheetByName("Orders");
    
    if (!ordersSheet) return;
    
    const data = ordersSheet.getDataRange().getValues();
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][1] === orderName) {
        ordersSheet.getRange(i + 1, 9).setValue(status);
        ordersSheet.getRange(i + 1, 10).setValue(goldenCards);
        return;
      }
    }
    
  } catch (error) {
    // Silent fail
  }
}

// ===== SETUP FORM TRIGGER =====
function setupFormTrigger() {
  try {
    const triggers = ScriptApp.getProjectTriggers();
    triggers.forEach(trigger => {
      if (trigger.getHandlerFunction() === 'onFormSubmit') {
        ScriptApp.deleteTrigger(trigger);
      }
    });
    
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    ScriptApp.newTrigger('onFormSubmit')
      .forSpreadsheet(ss)
      .onFormSubmit()
      .create();
    
    return "✓ Trigger created successfully";
    
  } catch (error) {
    return "✗ Error: " + error.toString();
  }
}
