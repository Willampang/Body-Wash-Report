//Auto Create Orders
class QiMenDunJiaCalculator {
  constructor() {
    this.tianGan = ['甲','乙','丙','丁','戊','己','庚','辛','壬','癸'];
    this.diZhi = ['子','丑','寅','卯','辰','巳','午','未','申','酉','戌','亥'];
    this.baMen = ['休门','死门','伤门','杜门','中宫','开门','惊门','生门','景门'];
    this.jiuXing = ['天蓬','天芮','天冲','天辅','天禽','天心','天柱','天任','天英'];
    this.jiuShen = ['直符','螣蛇','太阴','六合','白虎','玄武','九地','九天','太常'];
    this.jiuGong = ['乾六宫','坎一宫','艮八宫','震三宫','中五宫','兑七宫','巽四宫','离九宫','坤二宫'];

    this.jieQiJuShu = {
      '冬至':1,'小寒':1,'大寒':1,'立春':2,'雨水':2,'惊蛰':2,'春分':3,'清明':3,'谷雨':3,
      '立夏':4,'小满':4,'芒种':4,'夏至':5,'小暑':5,'大暑':5,'立秋':6,'处暑':6,'白露':6,
      '秋分':7,'寒露':7,'霜降':7,'立冬':8,'小雪':8,'大雪':8
    };

    this.goldCardMap = {
      "兑": "兑宫","艮": "艮宫","坎": "坎宫","坤": "坤宫",
      "离": "离宫","乾": "乾宫","巽": "巽宫","震": "震宫"
    };
  }

  calculateQiMen(year, month, day, hour, minute = 0) {
    const basicInfo = this.getBasicInfo(year, month, day, hour, minute);
    const juShu = this.getJuShu(basicInfo.jieQi, basicInfo.isYangDun);
    const zhiFuZhiShi = this.getZhiFuZhiShi(basicInfo.jiaZi, juShu);
    const jiuGongJu = this.arrangeJiuGong(juShu, zhiFuZhiShi);

    return {
      basicInfo,
      juShu,
      zhiFuZhiShi,
      jiuGongJu,
      interpretation: this.getInterpretation(jiuGongJu, basicInfo),
      goldCard: this.getGoldCard(jiuGongJu)
    };
  }

  getBasicInfo(year, month, day, hour, minute) {
    const date = new Date(year, month - 1, day, hour, minute);
    const jieQi = this.getJieQi(month, day);
    const isYangDun = this.isYangDun(jieQi);
    const jiaZi = (year + month + day + hour + minute) % 60;
    return { date, jieQi, isYangDun, jiaZi, dunJia: isYangDun ? '阳遁' : '阴遁' };
  }

  getJieQi(month, day) {
    const jieQiMap = {
      1: '小寒',2: '雨水',3: '春分',4: '谷雨',
      5: '立夏',6: '夏至',7: '大暑',8: '处暑',
      9: '秋分',10: '霜降',11: '小雪',12: '冬至'
    };
    return jieQiMap[month] || '未知';
  }

  isYangDun(jieQi) {
    const yangDunJieQi = ['冬至','小寒','大寒','立春','雨水','惊蛰','春分','清明','谷雨'];
    return yangDunJieQi.includes(jieQi);
  }

  getJuShu(jieQi, isYangDun) {
    let ju = this.jieQiJuShu[jieQi] || 1;
    return isYangDun ? ju : 9 - (ju - 1);
  }

  getZhiFuZhiShi(jiaZi, juShu) {
    const zhiFuIndex = jiaZi % this.jiuShen.length;
    const zhiShiIndex = (jiaZi + juShu) % this.baMen.length;
    return { zhiFu: this.jiuShen[zhiFuIndex], zhiShi: this.baMen[zhiShiIndex] };
  }

  arrangeJiuGong(juShu, zhiFuZhiShi) {
    return this.jiuGong.map((gong, i) => {
      const gongName = gong.replace(/[0-9宫六八三五七四九二]/g, "");
      return {
        gongWei: gong,
        men: this.baMen[(i + juShu) % this.baMen.length],
        xing: this.jiuXing[(i + juShu) % this.jiuXing.length],
        shen: this.jiuShen[(i + juShu) % this.jiuShen.length],
        goldCard: this.goldCardMap[gongName] || ""
      };
    });
  }

  getGoldCard(jiuGongJu) {
    const zhiFuGong = jiuGongJu.find(g => g.shen === "直符");
    return zhiFuGong ? zhiFuGong.goldCard : "";
  }

  getInterpretation(jiuGongJu, basicInfo) {
    const zhiFuGong = jiuGongJu.find(g => g.shen === "直符");
    let advice = "宜顺势而为，择吉方行动";

    if (zhiFuGong) {
      switch (zhiFuGong.goldCard) {
        case "乾宫": advice = "宜开拓进取，适合创业或掌权"; break;
        case "坎宫": advice = "宜静守学习，适合研究与规划"; break;
        case "艮宫": advice = "宜积累沉淀，适合投资与储蓄"; break;
        case "震宫": advice = "宜行动突破，适合营销与谈判"; break;
        case "巽宫": advice = "宜交流合作，适合谈判与社交"; break;
        case "离宫": advice = "宜宣传推广，适合文艺与传播"; break;
        case "坤宫": advice = "宜谦逊包容，适合养生与人和"; break;
        case "兑宫": advice = "宜享乐交际，适合娱乐与聚会"; break;
      }
    }

    return {
      overall: `${basicInfo.dunJia}${basicInfo.jieQi}局，整体能量平衡`,
      advice
    };
  }
}

// Enhanced flexible birthday parser
function parseFlexibleBirthday(birthdayInput) {
  if (!birthdayInput) return null;
  
  try {
    // If it's already a Date object, return it
    if (birthdayInput instanceof Date && !isNaN(birthdayInput.getTime())) {
      return birthdayInput;
    }
    
    // Convert to string and clean up
    let dateStr = String(birthdayInput).trim();
    
    // Remove ordinal suffixes (1st, 2nd, 3rd, 4th, etc.)
    dateStr = dateStr.replace(/(\d+)(st|nd|rd|th)/gi, '$1');
    
    // Remove extra spaces and normalize separators
    dateStr = dateStr.replace(/\s+/g, ' ').trim();
    
    // Array of date formats to try
    const formats = [
      // ISO formats
      /^(\d{4})[\/\-\.](\d{1,2})[\/\-\.](\d{1,2})$/, // yyyy-mm-dd, yyyy/mm/dd, yyyy.mm.dd
      /^(\d{1,2})[\/\-\.](\d{1,2})[\/\-\.](\d{4})$/, // dd-mm-yyyy, dd/mm/yyyy, dd.mm.yyyy, mm-dd-yyyy, mm/dd/yyyy, mm.dd.yyyy
      /^(\d{4})[\/\-\.](\d{1,2})[\/\-\.](\d{1,2})$/, // yyyy-dd-mm, yyyy/dd/mm, yyyy.dd.mm (duplicate but kept for clarity)
      
      // Month name formats
      /^([A-Za-z]{3,9})\s+(\d{1,2})[,\s]*(\d{4})$/, // "January 15 2024", "Jan 15, 2024"
      /^(\d{1,2})\s+([A-Za-z]{3,9})[,\s]*(\d{4})$/, // "15 January 2024", "15 Jan, 2024"
      /^(\d{4})\s+([A-Za-z]{3,9})\s+(\d{1,2})$/, // "2024 January 15"
      
      // Compact formats
      /^(\d{8})$/, // 20240115 (YYYYMMDD)
      /^(\d{2})(\d{2})(\d{4})$/, // 15012024 (DDMMYYYY)
      /^(\d{4})(\d{2})(\d{2})$/, // 20240115 (YYYYMMDD)
    ];
    
    let parsedDate = null;
    
    // Try standard JavaScript Date parsing first
    parsedDate = new Date(dateStr);
    if (!isNaN(parsedDate.getTime()) && parsedDate.getFullYear() > 1900 && parsedDate.getFullYear() < 2100) {
      return parsedDate;
    }
    
    // Try different formats
    for (let i = 0; i < formats.length; i++) {
      const match = dateStr.match(formats[i]);
      if (match) {
        let year, month, day;
        
        switch (i) {
          case 0: // yyyy-mm-dd format
            year = parseInt(match[1]);
            month = parseInt(match[2]);
            day = parseInt(match[3]);
            break;
            
          case 1: // dd-mm-yyyy or mm-dd-yyyy format
            // Try to determine if it's DD-MM-YYYY or MM-DD-YYYY
            const first = parseInt(match[1]);
            const second = parseInt(match[2]);
            year = parseInt(match[3]);
            
            // If first number > 12, it must be day (DD-MM-YYYY)
            if (first > 12) {
              day = first;
              month = second;
            }
            // If second number > 12, it must be day (MM-DD-YYYY)
            else if (second > 12) {
              month = first;
              day = second;
            }
            // Both <= 12, assume DD-MM-YYYY (common international format)
            else {
              day = first;
              month = second;
            }
            break;
            
          case 2: // yyyy-dd-mm format (less common but possible)
            year = parseInt(match[1]);
            day = parseInt(match[2]);
            month = parseInt(match[3]);
            break;
            
          case 3: // Month name first: "January 15 2024"
            month = getMonthNumber(match[1]);
            day = parseInt(match[2]);
            year = parseInt(match[3]);
            break;
            
          case 4: // Day first: "15 January 2024"
            day = parseInt(match[1]);
            month = getMonthNumber(match[2]);
            year = parseInt(match[3]);
            break;
            
          case 5: // Year first: "2024 January 15"
            year = parseInt(match[1]);
            month = getMonthNumber(match[2]);
            day = parseInt(match[3]);
            break;
            
          case 6: // YYYYMMDD (8 digits)
            const dateNum = match[1];
            year = parseInt(dateNum.substring(0, 4));
            month = parseInt(dateNum.substring(4, 6));
            day = parseInt(dateNum.substring(6, 8));
            break;
            
          case 7: // DDMMYYYY
            day = parseInt(match[1]);
            month = parseInt(match[2]);
            year = parseInt(match[3]);
            break;
            
          case 8: // YYYYMMDD (alternative)
            year = parseInt(match[1]);
            month = parseInt(match[2]);
            day = parseInt(match[3]);
            break;
        }
        
        // Validate date components
        if (year && month && day && 
            year >= 1900 && year <= 2100 && 
            month >= 1 && month <= 12 && 
            day >= 1 && day <= 31) {
          
          // Create date and validate it's real (handles leap years, days per month)
          parsedDate = new Date(year, month - 1, day);
          if (parsedDate.getFullYear() === year && 
              parsedDate.getMonth() === (month - 1) && 
              parsedDate.getDate() === day) {
            return parsedDate;
          }
        }
      }
    }    
    // Handle formats like "2024-1-5" or "5-1-2024"
    const parts = dateStr.split(/[\/\-\.\s,]+/).filter(p => p && p.match(/\d/));
    if (parts.length >= 3) {
      const nums = parts.map(p => parseInt(p)).filter(n => !isNaN(n));
      if (nums.length >= 3) {
        // Try different arrangements
        const arrangements = [
          [nums[0], nums[1], nums[2]], // as given
          [nums[2], nums[1], nums[0]], // reverse
          [nums[1], nums[0], nums[2]], // swap first two
        ];
        
        for (let arr of arrangements) {
          // Determine year, month, day
          let year, month, day;
          
          // Find the year (4 digits or > 31)
          if (arr[0] > 31 || arr[0].toString().length === 4) {
            year = arr[0];
            month = arr[1];
            day = arr[2];
          } else if (arr[2] > 31 || arr[2].toString().length === 4) {
            day = arr[0];
            month = arr[1];
            year = arr[2];
          } else if (arr[1] > 31 || arr[1].toString().length === 4) {
            month = arr[0];
            year = arr[1];
            day = arr[2];
          }
          
          // Handle 2-digit years
          if (year && year < 100) {
            year += (year < 50) ? 2000 : 1900;
          }
          
          if (year && month && day && 
              year >= 1900 && year <= 2100 && 
              month >= 1 && month <= 12 && 
              day >= 1 && day <= 31) {
            
            parsedDate = new Date(year, month - 1, day);
            if (parsedDate.getFullYear() === year && 
                parsedDate.getMonth() === (month - 1) && 
                parsedDate.getDate() === day) {
              return parsedDate;
            }
          }
        }
      }
    }
    
    return null;
  } catch (e) {
    return null;
  }
}

function getMonthNumber(monthStr) {
  const months = {
    'january': 1, 'jan': 1,
    'february': 2, 'feb': 2,
    'march': 3, 'mar': 3,
    'april': 4, 'apr': 4,
    'may': 5,
    'june': 6, 'jun': 6,
    'july': 7, 'jul': 7,
    'august': 8, 'aug': 8,
    'september': 9, 'sep': 9, 'sept': 9,
    'october': 10, 'oct': 10,
    'november': 11, 'nov': 11,
    'december': 12, 'dec': 12
  };
  
  return months[monthStr.toLowerCase()] || parseInt(monthStr);
}

// Updated formatBirthday function
function formatBirthday(birthday) {
  if (!birthday) return "";
  
  try {
    const date = parseFlexibleBirthday(birthday);
    
    if (!date) {
      return String(birthday);
    }
    
    var options = { year: 'numeric', month: 'long', day: 'numeric' };
    return date.toLocaleDateString('en-US', options);
  } catch (e) {
    return String(birthday);
  }
}

// Updated calculateQimenForBirthday function
function calculateQimenForBirthday(birthday, birthHour) {
  if (!birthday) {
    return null;
  }
  
  try {
    // Use the flexible birthday parser
    const date = parseFlexibleBirthday(birthday);
    
    if (!date) {
      return null;
    }
    
    const calculator = new QiMenDunJiaCalculator();
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    const day = date.getDate();
    
    // Use birth hour from spreadsheet if provided, otherwise default calculation
    var hour, minute;
    if (birthHour && birthHour !== "") {
      // Parse birth hour - could be in format like "14", "14:30", "2pm", etc.
      var hourStr = String(birthHour).trim();
      
      // Handle AM/PM format
      let isPM = /pm|p\.m\.|下午/i.test(hourStr);
      let isAM = /am|a\.m\.|上午/i.test(hourStr);
      
      // Clean the hour string
      hourStr = hourStr.replace(/[apm\.上下午\s]/gi, '');
      
      if (hourStr.includes(':')) {
        var timeParts = hourStr.split(':');
        hour = parseInt(timeParts[0]) || 8;
        minute = parseInt(timeParts[1]) || 0;
      } else {
        hour = parseInt(hourStr) || 8;
        minute = 0;
      }
      
      // Convert 12-hour to 24-hour format
      if (isPM && hour < 12) {
        hour += 12;
      } else if (isAM && hour === 12) {
        hour = 0;
      }
      
      // Ensure hour is within valid range
      hour = Math.max(0, Math.min(23, hour));
      minute = Math.max(0, Math.min(59, minute));
      
    } else {
      // Fallback to original calculation if no birth hour provided
      hour = (8 + (day % 8)) % 24;
      minute = ((day * 11) + (month * 7)) % 60;
    }
    
    const result = calculator.calculateQiMen(year, month, day, hour, minute);
    
    return result.goldCard;
  } catch (e) {
    return null;
  }
}

function onNewRow(e) {
  var spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  if (!spreadsheet) return;
  
  var sheet = spreadsheet.getSheetByName("Sheet1");
  if (!sheet) sheet = spreadsheet.getSheets()[0];
  if (!sheet) return;
  
  var row;
  if (e && e.range) {
    row = e.range.getRow();
  } else {
    var lastRow = sheet.getLastRow();
    if (lastRow <= 1) return;
    row = lastRow;
  }
  if (row === 1) return;
  
  var name = "";
  var email = "";
  var streetAddress = "";
  var city = "";
  var state = "";
  var country = "";
  var postalCode = "";
  var phone = "";
  var customerBirthday = null;
  var birthHour = ""; // Birth hour
  var qty丰盛款 = 0;
  var qty富豪款 = 0;
  var qty吸金款 = 0;
  var qty聚财款 = 0; // New product
  var qty带财款 = 0; // Add 带财款
  
  try {
    name = sheet.getRange(row, 1).getValue();           // Col A: Name
    email = sheet.getRange(row, 2).getValue();          // Col B: Email  
    streetAddress = sheet.getRange(row, 3).getValue();  // Col C: Street Address
    city = sheet.getRange(row, 4).getValue();           // Col D: City
    state = sheet.getRange(row, 5).getValue();          // Col E: State
    country = sheet.getRange(row, 6).getValue();        // Col F: Country
    postalCode = sheet.getRange(row, 7).getValue();     // Col G: Postal Code
    phone = sheet.getRange(row, 8).getValue();          // Col H: Phone
    customerBirthday = sheet.getRange(row, 9).getValue(); // Col I: Customer Birthday
    birthHour = sheet.getRange(row, 10).getValue();     // Col J: 出生时辰 (Birth Hour)
    qty丰盛款 = sheet.getRange(row, 11).getValue();      // Col K: 丰盛款
    qty富豪款 = sheet.getRange(row, 12).getValue();      // Col L: 富豪款
    qty吸金款 = sheet.getRange(row, 13).getValue();      // Col M: 吸金款
    qty带财款 = sheet.getRange(row, 14).getValue();      // Col O: 带财款
    qty聚财款 = sheet.getRange(row, 15).getValue();      // Col N: 聚财款
  } catch (error) {
    sheet.getRange(row, 16).setValue("Read Error: " + error.message); // Result column P
    return;
  }
  
  name = name ? String(name).trim() : "";
  email = email ? String(email).trim() : "";
  streetAddress = streetAddress ? String(streetAddress).trim() : "";
  city = city ? String(city).trim() : "";
  state = state ? String(state).trim() : "";
  country = country ? String(country).trim() : "";
  postalCode = postalCode ? String(postalCode).trim() : "";
  phone = phone ? String(phone).trim() : "";
  birthHour = birthHour ? String(birthHour).trim() : "";
  
  qty丰盛款 = Number(qty丰盛款) || 0;
  qty富豪款 = Number(qty富豪款) || 0;
  qty吸金款 = Number(qty吸金款) || 0;
  qty聚财款 = Number(qty聚财款) || 0;
  qty带财款 = Number(qty带财款) || 0;
  
  if (!name) {
    sheet.getRange(row, 16).setValue("Error: No name");
    return;
  }

  if (!email) {
    sheet.getRange(row, 16).setValue("Error: No email provided");
    return;
  }

  if (qty丰盛款 <= 0 && qty富豪款 <= 0 && qty吸金款 <= 0 && qty聚财款 <= 0 && qty带财款 <= 0) {
    sheet.getRange(row, 16).setValue("No products ordered");
    return;
  }

  var store = "ns6gks-k1.myshopify.com";   
  var token = "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";

  var customerId = null;
  var existingCustomer = null;
  if (email) {
    var searchUrl = "https://" + store + "/admin/api/2025-01/customers/search.json?query=email:" + encodeURIComponent(email);
    var searchOptions = {
      "method": "get",
      "headers": { "X-Shopify-Access-Token": token },
      "muteHttpExceptions": true
    };
    var searchResponse = UrlFetchApp.fetch(searchUrl, searchOptions);
    var searchData = JSON.parse(searchResponse.getContentText());
    if (searchData.customers && searchData.customers.length > 0) {
      existingCustomer = searchData.customers[0];
      customerId = existingCustomer.id;
    }
  }

  var lineItems = []; 
  
  var products = {
    "丰盛款": { variant_id: 51126212001924, price: "496.00", title: "丰盛款" },
    "富豪款": { variant_id: 51126213738628, price: "397.00", title: "富豪款" },
    "吸金款": { variant_id: 51126213771396, price: "196.00", title: "吸金款" },
    "聚财款": { variant_id: 51126213836932, price: "496.00", title: "聚财款" }, // NEW PRODUCT
    "带财款": { variant_id: 51126213869700, price: "296.00", title: "带财款" },
    "天圆地方铜钱": { variant_id: 51126213902468, price: "0.00", title: "天圆地方铜钱" },
    "乾宫": { variant_id: 51126213968004, price: "0.00", title: "乾宫" },
    "坎宫": { variant_id: 51126214033540, price: "0.00", title: "坎宫" },
    "艮宫": { variant_id: 51126214099076, price: "0.00", title: "艮宫" },
    "震宫": { variant_id: 51126214131844, price: "0.00", title: "震宫" },
    "巽宫": { variant_id: 51126214164612, price: "0.00", title: "巽宫" },
    "离宫": { variant_id: 51126214197380, price: "0.00", title: "离宫" },
    "坤宫": { variant_id: 51126214262916, price: "0.00", title: "坤宫" },
    "兑宫": { variant_id: 51126217670788, price: "0.00", title: "兑宫" }
  };
  
  if (qty丰盛款 > 0) {
    lineItems.push({
      "variant_id": products["丰盛款"].variant_id,
      "quantity": qty丰盛款
    });
  }
  
  if (qty富豪款 > 0) {
    lineItems.push({
      "variant_id": products["富豪款"].variant_id,
      "quantity": qty富豪款
    });
  }
  
  if (qty吸金款 > 0) {
    lineItems.push({
      "variant_id": products["吸金款"].variant_id,
      "quantity": qty吸金款
    });
  }

  if (qty聚财款 > 0) {
    lineItems.push({
      "variant_id": products["聚财款"].variant_id,
      "quantity": qty聚财款
    });
  }

  if (qty带财款 > 0) {
    lineItems.push({
      "variant_id": products["带财款"].variant_id,
      "quantity": qty带财款
    });
  }

  // Calculate total order value (including 聚财款 and 带财款)
  var totalOrderValue = (qty丰盛款 * 496) + (qty富豪款 * 397) + (qty吸金款 * 196) + (qty聚财款 * 496) + (qty带财款 * 296);
  
  // Add bonus items based on order value - EXCLUSIVE TIERS
  var copperCoinsQuantity = 0;
  
  // Check tiers from highest to lowest (exclusive)
  if (totalOrderValue >= 2000) {
    // 2000+ tier: Only 带财款 + 4 copper coins
    lineItems.push({
      "variant_id": products["带财款"].variant_id,
      "quantity": 1,
      "price": 0.00
    });
    copperCoinsQuantity = 4;
  } else if (totalOrderValue >= 1500) {
    // 1500-1999 tier: Only 吸金款 + 3 copper coins
    lineItems.push({
      "variant_id": products["吸金款"].variant_id,
      "quantity": 1,
      "price": 0.00
    });
    copperCoinsQuantity = 3;
  } else if (totalOrderValue >= 800) {
    // 800-1499 tier: Only 2 copper coins
    copperCoinsQuantity = 2;
  }
  
  // Add copper coins if any are to be given
  if (copperCoinsQuantity > 0) {
    lineItems.push({
      "variant_id": products["天圆地方铜钱"].variant_id,
      "quantity": copperCoinsQuantity
    });
  }

  // Calculate and add golden card using birth hour if customer has any product and valid birthday
  var goldenCard = null;
  var totalProducts = qty丰盛款 + qty富豪款 + qty吸金款 + qty聚财款 + qty带财款;
  
  if (totalProducts > 0 && customerBirthday) {
    goldenCard = calculateQimenForBirthday(customerBirthday, birthHour);
    
    if (goldenCard && products[goldenCard]) {
      lineItems.push({
        "variant_id": products[goldenCard].variant_id,
        "quantity": 1
      });
    }
  }

  var customerData = {};
  if (customerId) {
    customerData = { "id": customerId };
  } else if (email) {
    customerData = { "email": email };
  }

  var noteText = "Customer: " + (name || "Name not provided");
  
  // Add main email on new line
  if (email) {
    noteText += "\nEmail: " + email;
  }
  
  // Add birthday information if available
  if (customerBirthday) {
    var formattedBirthday = formatBirthday(customerBirthday);
    if (formattedBirthday) {
      noteText += "\nBirthday: " + formattedBirthday;
    } else {
      noteText += "\nBirthday: " + String(customerBirthday);
    }
  }
  
  if (goldenCard) {
    noteText += "\nGolden Card: " + goldenCard;
  }

  var payload = {
    "order": {
      "line_items": lineItems,
      "billing_address": {
        "first_name": name || "Customer",
        "last_name": "",
        "phone": phone || "",
        "address1": streetAddress || "N/A",
        "city": city || "Kuala Lumpur", 
        "province": state || "",
        "country": country || "Malaysia",
        "zip": postalCode || ""
      },
      "shipping_address": {
        "first_name": name || "Customer",
        "last_name": "",
        "phone": phone || "",
        "address1": streetAddress || "N/A",
        "city": city || "Kuala Lumpur",
        "province": state || "",
        "country": country || "Malaysia",
        "zip": postalCode || ""
      },
      "note": noteText,
      "tags": "On Hold,Google Sheet Import,GHL",
      "financial_status": "pending",
      "send_receipt": false,
      "send_fulfillment_receipt": false,
      "inventory_behaviour": "decrement_obeying_policy"
    }
  };

  // Add customer data if available
  if (Object.keys(customerData).length > 0) {
    payload.order.customer = customerData;
  }

  // Use orders endpoint
  var url = "https://" + store + "/admin/api/2025-01/orders.json";
  var options = {
    "method": "post",
    "headers": {
      "X-Shopify-Access-Token": token,
      "Content-Type": "application/json"
    },
    "payload": JSON.stringify(payload),
    "muteHttpExceptions": true
  };

  var response = UrlFetchApp.fetch(url, options);
  var responseCode = response.getResponseCode();
  var data = JSON.parse(response.getContentText());

  // Handle response
  if (responseCode >= 200 && responseCode < 300 && data.order) {
    var resultMsg = "Order Created: " + data.order.id + " (RM" + totalOrderValue + ")";
    if (goldenCard) {
      resultMsg += " | Golden Card: " + goldenCard;
    }
    if (totalOrderValue >= 2000) {
      resultMsg += " | +带财款+4 Coins";
    } else if (totalOrderValue >= 1500) {
      resultMsg += " | +吸金款+3 Coins";  
    } else if (totalOrderValue >= 800) {
      resultMsg += " | +2 Coins";
    }
    sheet.getRange(row, 16).setValue(resultMsg);
  } else {
    var errorMsg = "Error (" + responseCode + "): ";
    if (data.errors) {
      errorMsg += JSON.stringify(data.errors);
    } else {
      errorMsg += response.getContentText();
    }
    sheet.getRange(row, 16).setValue(errorMsg);
  }
}

function QIMEN(birthday, hour, minute) {
  const date = parseFlexibleBirthday(birthday);
  if (!date) {
    return "Invalid date format";
  }
  
  const year = date.getFullYear();
  const month = date.getMonth() + 1;
  const day = date.getDate();

  const calculator = new QiMenDunJiaCalculator();
  const r = calculator.calculateQiMen(year, month, day, hour || 0, minute || 0);
  return `遁甲:${r.basicInfo.dunJia}, 局数:${r.juShu}, 值符:${r.zhiFuZhiShi.zhiFu}, 黄金卡:${r.goldCard}`;
}

function QIMEN_ANALYSIS(birthday, hour, minute) {
  const date = parseFlexibleBirthday(birthday);
  if (!date) {
    return JSON.stringify({ error: "Invalid date format" });
  }
  
  const year = date.getFullYear();
  const month = date.getMonth() + 1;
  const day = date.getDate();

  const calculator = new QiMenDunJiaCalculator();
  const r = calculator.calculateQiMen(year, month, day, hour || 0, minute || 0);
  return JSON.stringify(r);
}
