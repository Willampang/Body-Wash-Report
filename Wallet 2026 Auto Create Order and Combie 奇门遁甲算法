//Auto Create Orders
class QiMenDunJiaCalculator {
  constructor() {
    this.tianGan = ['甲','乙','丙','丁','戊','己','庚','辛','壬','癸'];
    this.diZhi = ['子','丑','寅','卯','辰','巳','午','未','申','酉','戌','亥'];
    this.baMen = ['休门','死门','伤门','杜门','中宫','开门','惊门','生门','景门'];
    this.jiuXing = ['天蓬','天芮','天冲','天辅','天禽','天心','天柱','天任','天英'];
    this.jiuShen = ['直符','螣蛇','太阴','六合','白虎','玄武','九地','九天','太常'];
    this.jiuGong = ['乾六宫','坎一宫','艮八宫','震三宫','中五宫','兑七宫','巽四宫','离九宫','坤二宫'];

    this.jieQiJuShu = {
      '冬至':1,'小寒':1,'大寒':1,'立春':2,'雨水':2,'惊蛰':2,'春分':3,'清明':3,'谷雨':3,
      '立夏':4,'小满':4,'芒种':4,'夏至':5,'小暑':5,'大暑':5,'立秋':6,'处暑':6,'白露':6,
      '秋分':7,'寒露':7,'霜降':7,'立冬':8,'小雪':8,'大雪':8
    };

    this.goldCardMap = {
      "兑": "兑宫","艮": "艮宫","坎": "坎宫","坤": "坤宫",
      "离": "离宫","乾": "乾宫","巽": "巽宫","震": "震宫"
    };
  }

  calculateQiMen(year, month, day, hour, minute = 0) {
    const basicInfo = this.getBasicInfo(year, month, day, hour, minute);
    const juShu = this.getJuShu(basicInfo.jieQi, basicInfo.isYangDun);
    const zhiFuZhiShi = this.getZhiFuZhiShi(basicInfo.jiaZi, juShu);
    const jiuGongJu = this.arrangeJiuGong(juShu, zhiFuZhiShi);

    return {
      basicInfo,
      juShu,
      zhiFuZhiShi,
      jiuGongJu,
      interpretation: this.getInterpretation(jiuGongJu, basicInfo),
      goldCard: this.getGoldCard(jiuGongJu)
    };
  }

  getBasicInfo(year, month, day, hour, minute) {
    const date = new Date(year, month - 1, day, hour, minute);
    const jieQi = this.getJieQi(month, day);
    const isYangDun = this.isYangDun(jieQi);
    const jiaZi = (year + month + day + hour + minute) % 60;
    return { date, jieQi, isYangDun, jiaZi, dunJia: isYangDun ? '阳遁' : '阴遁' };
  }

  getJieQi(month, day) {
    const jieQiMap = {
      1: '小寒',2: '雨水',3: '春分',4: '谷雨',
      5: '立夏',6: '夏至',7: '大暑',8: '处暑',
      9: '秋分',10: '霜降',11: '小雪',12: '冬至'
    };
    return jieQiMap[month] || '未知';
  }

  isYangDun(jieQi) {
    const yangDunJieQi = ['冬至','小寒','大寒','立春','雨水','惊蛰','春分','清明','谷雨'];
    return yangDunJieQi.includes(jieQi);
  }

  getJuShu(jieQi, isYangDun) {
    let ju = this.jieQiJuShu[jieQi] || 1;
    return isYangDun ? ju : 9 - (ju - 1);
  }

  getZhiFuZhiShi(jiaZi, juShu) {
    const zhiFuIndex = jiaZi % this.jiuShen.length;
    const zhiShiIndex = (jiaZi + juShu) % this.baMen.length;
    return { zhiFu: this.jiuShen[zhiFuIndex], zhiShi: this.baMen[zhiShiIndex] };
  }

  arrangeJiuGong(juShu, zhiFuZhiShi) {
    return this.jiuGong.map((gong, i) => {
      const gongName = gong.replace(/[0-9宫六八三五七四九二]/g, "");
      return {
        gongWei: gong,
        men: this.baMen[(i + juShu) % this.baMen.length],
        xing: this.jiuXing[(i + juShu) % this.jiuXing.length],
        shen: this.jiuShen[(i + juShu) % this.jiuShen.length],
        goldCard: this.goldCardMap[gongName] || ""
      };
    });
  }

  getGoldCard(jiuGongJu) {
    const zhiFuGong = jiuGongJu.find(g => g.shen === "直符");
    return zhiFuGong ? zhiFuGong.goldCard : "";
  }

  getInterpretation(jiuGongJu, basicInfo) {
    const zhiFuGong = jiuGongJu.find(g => g.shen === "直符");
    let advice = "宜顺势而为，择吉方行动";

    if (zhiFuGong) {
      switch (zhiFuGong.goldCard) {
        case "乾宫": advice = "宜开拓进取，适合创业或掌权"; break;
        case "坎宫": advice = "宜静守学习，适合研究与规划"; break;
        case "艮宫": advice = "宜积累沉淀，适合投资与储蓄"; break;
        case "震宫": advice = "宜行动突破，适合营销与谈判"; break;
        case "巽宫": advice = "宜交流合作，适合谈判与社交"; break;
        case "离宫": advice = "宜宣传推广，适合文艺与传播"; break;
        case "坤宫": advice = "宜谦逊包容，适合养生与人和"; break;
        case "兑宫": advice = "宜享乐交际，适合娱乐与聚会"; break;
      }
    }

    return {
      overall: `${basicInfo.dunJia}${basicInfo.jieQi}局，整体能量平衡`,
      advice
    };
  }
}

function parseFlexibleBirthday(birthdayInput) {
  if (!birthdayInput) return null;
  
  try {
    if (birthdayInput instanceof Date && !isNaN(birthdayInput.getTime())) {
      return birthdayInput;
    }
    
    let dateStr = String(birthdayInput).trim();
    dateStr = dateStr.replace(/(\d+)(st|nd|rd|th)/gi, '$1');
    dateStr = dateStr.replace(/\s+/g, ' ').trim();
    
    let parsedDate = new Date(dateStr);
    if (!isNaN(parsedDate.getTime()) && parsedDate.getFullYear() > 1900 && parsedDate.getFullYear() < 2100) {
      return parsedDate;
    }
    
    const formats = [
      /^(\d{4})[\/\-\.](\d{1,2})[\/\-\.](\d{1,2})$/,
      /^(\d{1,2})[\/\-\.](\d{1,2})[\/\-\.](\d{4})$/,
      /^([A-Za-z]{3,9})\s+(\d{1,2})[,\s]*(\d{4})$/,
      /^(\d{1,2})\s+([A-Za-z]{3,9})[,\s]*(\d{4})$/,
      /^(\d{4})\s+([A-Za-z]{3,9})\s+(\d{1,2})$/,
      /^(\d{8})$/,
      /^(\d{2})(\d{2})(\d{4})$/
    ];
    
    for (let i = 0; i < formats.length; i++) {
      const match = dateStr.match(formats[i]);
      if (match) {
        let year, month, day;
        
        switch (i) {
          case 0:
            year = parseInt(match[1]);
            month = parseInt(match[2]);
            day = parseInt(match[3]);
            break;
            
          case 1:
            const first = parseInt(match[1]);
            const second = parseInt(match[2]);
            year = parseInt(match[3]);
            
            if (first > 12) {
              day = first;
              month = second;
            } else if (second > 12) {
              month = first;
              day = second;
            } else {
              day = first;
              month = second;
            }
            break;
            
          case 2:
            month = getMonthNumber(match[1]);
            day = parseInt(match[2]);
            year = parseInt(match[3]);
            break;
            
          case 3:
            day = parseInt(match[1]);
            month = getMonthNumber(match[2]);
            year = parseInt(match[3]);
            break;
            
          case 4:
            year = parseInt(match[1]);
            month = getMonthNumber(match[2]);
            day = parseInt(match[3]);
            break;
            
          case 5:
            const dateNum = match[1];
            year = parseInt(dateNum.substring(0, 4));
            month = parseInt(dateNum.substring(4, 6));
            day = parseInt(dateNum.substring(6, 8));
            break;
            
          case 6:
            day = parseInt(match[1]);
            month = parseInt(match[2]);
            year = parseInt(match[3]);
            break;
        }
        
        if (year && month && day && 
            year >= 1900 && year <= 2100 && 
            month >= 1 && month <= 12 && 
            day >= 1 && day <= 31) {
          
          parsedDate = new Date(year, month - 1, day);
          if (parsedDate.getFullYear() === year && 
              parsedDate.getMonth() === (month - 1) && 
              parsedDate.getDate() === day) {
            return parsedDate;
          }
        }
      }
    }
    
    const parts = dateStr.split(/[\/\-\.\s,]+/).filter(p => p && p.match(/\d/));
    if (parts.length >= 3) {
      const nums = parts.map(p => parseInt(p)).filter(n => !isNaN(n));
      if (nums.length >= 3) {
        const arrangements = [
          [nums[0], nums[1], nums[2]],
          [nums[2], nums[1], nums[0]],
          [nums[1], nums[0], nums[2]]
        ];
        
        for (let arr of arrangements) {
          let year, month, day;
          
          if (arr[0] > 31 || arr[0].toString().length === 4) {
            year = arr[0];
            month = arr[1];
            day = arr[2];
          } else if (arr[2] > 31 || arr[2].toString().length === 4) {
            day = arr[0];
            month = arr[1];
            year = arr[2];
          } else if (arr[1] > 31 || arr[1].toString().length === 4) {
            month = arr[0];
            year = arr[1];
            day = arr[2];
          }
          
          if (year && year < 100) {
            year += (year < 50) ? 2000 : 1900;
          }
          
          if (year && month && day && 
              year >= 1900 && year <= 2100 && 
              month >= 1 && month <= 12 && 
              day >= 1 && day <= 31) {
            
            parsedDate = new Date(year, month - 1, day);
            if (parsedDate.getFullYear() === year && 
                parsedDate.getMonth() === (month - 1) && 
                parsedDate.getDate() === day) {
              return parsedDate;
            }
          }
        }
      }
    }
    
    return null;
  } catch (e) {
    return null;
  }
}

function getMonthNumber(monthStr) {
  const months = {
    'january': 1, 'jan': 1,
    'february': 2, 'feb': 2,
    'march': 3, 'mar': 3,
    'april': 4, 'apr': 4,
    'may': 5,
    'june': 6, 'jun': 6,
    'july': 7, 'jul': 7,
    'august': 8, 'aug': 8,
    'september': 9, 'sep': 9, 'sept': 9,
    'october': 10, 'oct': 10,
    'november': 11, 'nov': 11,
    'december': 12, 'dec': 12
  };
  
  return months[monthStr.toLowerCase()] || parseInt(monthStr);
}

function formatBirthday(birthday) {
  if (!birthday) return "";
  
  try {
    const date = parseFlexibleBirthday(birthday);
    if (!date) return String(birthday);
    
    var options = { year: 'numeric', month: 'long', day: 'numeric' };
    return date.toLocaleDateString('en-US', options);
  } catch (e) {
    return String(birthday);
  }
}

function calculateQimenForBirthday(birthday, birthHour) {
  if (!birthday) return null;
  
  try {
    const date = parseFlexibleBirthday(birthday);
    if (!date) return null;
    
    const calculator = new QiMenDunJiaCalculator();
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    const day = date.getDate();
    
    var hour, minute;
    if (birthHour && birthHour !== "") {
      var hourStr = String(birthHour).trim();
      let isPM = /pm|p\.m\.|下午/i.test(hourStr);
      let isAM = /am|a\.m\.|上午/i.test(hourStr);
      hourStr = hourStr.replace(/[apm\.上下午\s]/gi, '');
      
      if (hourStr.includes(':')) {
        var timeParts = hourStr.split(':');
        hour = parseInt(timeParts[0]) || 8;
        minute = parseInt(timeParts[1]) || 0;
      } else {
        hour = parseInt(hourStr) || 8;
        minute = 0;
      }
      
      if (isPM && hour < 12) hour += 12;
      else if (isAM && hour === 12) hour = 0;
      
      hour = Math.max(0, Math.min(23, hour));
      minute = Math.max(0, Math.min(59, minute));
    } else {
      hour = (8 + (day % 8)) % 24;
      minute = ((day * 11) + (month * 7)) % 60;
    }
    
    const result = calculator.calculateQiMen(year, month, day, hour, minute);
    return result.goldCard;
  } catch (e) {
    return null;
  }
}

function onNewRow(e) {
  var spreadsheet = SpreadsheetApp.getActiveSpreadsheet();
  if (!spreadsheet) return;
  
  var sheet = spreadsheet.getSheetByName("Sheet1");
  if (!sheet) sheet = spreadsheet.getSheets()[0];
  if (!sheet) return;
  
  var row;
  if (e && e.range) {
    row = e.range.getRow();
  } else {
    var lastRow = sheet.getLastRow();
    if (lastRow <= 1) return;
    row = lastRow;
  }
  if (row === 1) return;
  
  var name = "";
  var email = "";
  var streetAddress = "";
  var city = "";
  var state = "";
  var country = "";
  var postalCode = "";
  var phone = "";
  var customerBirthday = null;
  var birthHour = "";
  var qty丰盛款 = 0;
  var qty富豪款 = 0;
  var qty吸金款 = 0;
  var qty聚财款 = 0;
  var qty带财款 = 0;
  
  try {
    name = sheet.getRange(row, 1).getValue();
    email = sheet.getRange(row, 2).getValue();
    streetAddress = sheet.getRange(row, 3).getValue();
    city = sheet.getRange(row, 4).getValue();
    state = sheet.getRange(row, 5).getValue();
    country = sheet.getRange(row, 6).getValue();
    postalCode = sheet.getRange(row, 7).getValue();
    phone = sheet.getRange(row, 8).getValue();
    customerBirthday = sheet.getRange(row, 9).getValue();
    birthHour = sheet.getRange(row, 10).getValue();
    qty丰盛款 = sheet.getRange(row, 11).getValue();
    qty富豪款 = sheet.getRange(row, 12).getValue();
    qty吸金款 = sheet.getRange(row, 13).getValue();
    qty带财款 = sheet.getRange(row, 14).getValue();
    qty聚财款 = sheet.getRange(row, 15).getValue();
  } catch (error) {
    sheet.getRange(row, 16).setValue("Read Error: " + error.message);
    return;
  }
  
  name = name ? String(name).trim() : "";
  email = email ? String(email).trim() : "";
  streetAddress = streetAddress ? String(streetAddress).trim() : "";
  city = city ? String(city).trim() : "";
  state = state ? String(state).trim() : "";
  country = country ? String(country).trim() : "";
  postalCode = postalCode ? String(postalCode).trim() : "";
  phone = phone ? String(phone).trim() : "";
  birthHour = birthHour ? String(birthHour).trim() : "";
  
  qty丰盛款 = Number(qty丰盛款) || 0;
  qty富豪款 = Number(qty富豪款) || 0;
  qty吸金款 = Number(qty吸金款) || 0;
  qty聚财款 = Number(qty聚财款) || 0;
  qty带财款 = Number(qty带财款) || 0;
  
  if (!name) {
    sheet.getRange(row, 16).setValue("Error: No name");
    return;
  }

  if (!email) {
    sheet.getRange(row, 16).setValue("Error: No email provided");
    return;
  }

  if (qty丰盛款 <= 0 && qty富豪款 <= 0 && qty吸金款 <= 0 && qty聚财款 <= 0 && qty带财款 <= 0) {
    sheet.getRange(row, 16).setValue("No products ordered");
    return;
  }

  var store = "z14sj1-i5.myshopify.com";
  var token = "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";

  var customerId = null;
  if (email) {
    var searchUrl = "https://" + store + "/admin/api/2025-01/customers/search.json?query=email:" + encodeURIComponent(email);
    var searchOptions = {
      "method": "get",
      "headers": { "X-Shopify-Access-Token": token },
      "muteHttpExceptions": true
    };
    var searchResponse = UrlFetchApp.fetch(searchUrl, searchOptions);
    var searchData = JSON.parse(searchResponse.getContentText());
    if (searchData.customers && searchData.customers.length > 0) {
      customerId = searchData.customers[0].id;
    }
  }

  var lineItems = [];
  
  var products = {
    "丰盛款": { variant_id: 46719018434726, price: 496.00 },
    "富豪款": { variant_id: 46719018369190, price: 397.00 },
    "吸金款": { variant_id: 46719018270886, price: 196.00 },
    "聚财款": { variant_id: 46719018172582, price: 496.00 },
    "带财款": { variant_id: 46719018074278, price: 296.00 },
    "天圆地方铜钱": { variant_id: 46719018008742, price: 0.00 },
    "乾宫": { variant_id: 46719017943206, price: 0.00 },
    "坎宫": { variant_id: 46719017844902, price: 0.00 },
    "艮宫": { variant_id: 46719017779366, price: 0.00 },
    "震宫": { variant_id: 46719017681062, price: 0.00 },
    "巽宫": { variant_id: 46719017615526, price: 0.00 },
    "离宫": { variant_id: 46719017517222, price: 0.00 },
    "坤宫": { variant_id: 46719017451686, price: 0.00 },
    "兑宫": { variant_id: 46719017353382, price: 0.00 }
  };
  
  if (qty丰盛款 > 0) lineItems.push({ "variant_id": products["丰盛款"].variant_id, "quantity": qty丰盛款 });
  if (qty富豪款 > 0) lineItems.push({ "variant_id": products["富豪款"].variant_id, "quantity": qty富豪款 });
  if (qty吸金款 > 0) lineItems.push({ "variant_id": products["吸金款"].variant_id, "quantity": qty吸金款 });
  if (qty聚财款 > 0) lineItems.push({ "variant_id": products["聚财款"].variant_id, "quantity": qty聚财款 });
  if (qty带财款 > 0) lineItems.push({ "variant_id": products["带财款"].variant_id, "quantity": qty带财款 });

  var totalOrderValue = (qty丰盛款 * 496) + (qty富豪款 * 397) + (qty吸金款 * 196) + (qty聚财款 * 496) + (qty带财款 * 296);
  
  var copperCoinsQuantity = 0;
  
  if (totalOrderValue >= 2000) {
    lineItems.push({ "variant_id": products["带财款"].variant_id, "quantity": 1, "price": 0.00 });
    copperCoinsQuantity = 4;
  } else if (totalOrderValue >= 1500) {
    lineItems.push({ "variant_id": products["吸金款"].variant_id, "quantity": 1, "price": 0.00 });
    copperCoinsQuantity = 3;
  } else if (totalOrderValue >= 800) {
    copperCoinsQuantity = 2;
  }
  
  if (copperCoinsQuantity > 0) {
    lineItems.push({ "variant_id": products["天圆地方铜钱"].variant_id, "quantity": copperCoinsQuantity });
  }

  var goldenCard = null;
  var totalProducts = qty丰盛款 + qty富豪款 + qty吸金款 + qty聚财款 + qty带财款;
  
  if (totalProducts > 0 && customerBirthday) {
    goldenCard = calculateQimenForBirthday(customerBirthday, birthHour);
    
    if (goldenCard && products[goldenCard]) {
      var alreadyHasGoldenCard = lineItems.some(function(item) {
        return item.variant_id === products[goldenCard].variant_id;
      });
      
      if (!alreadyHasGoldenCard) {
        lineItems.push({ "variant_id": products[goldenCard].variant_id, "quantity": 1 });
      }
    }
  }

  var customerData = {};
  if (customerId) {
    customerData = { "id": customerId };
  } else if (email) {
    customerData = { "email": email };
  }

  var noteText = "Customer: " + (name || "Name not provided");
  if (email) noteText += "\nEmail: " + email;
  
  if (customerBirthday) {
    var formattedBirthday = formatBirthday(customerBirthday);
    noteText += "\nBirthday: " + (formattedBirthday || String(customerBirthday));
  }
  
  if (goldenCard) noteText += "\nGolden Card: " + goldenCard;

  var payload = {
    "order": {
      "line_items": lineItems,
      "billing_address": {
        "first_name": name || "Customer",
        "last_name": "",
        "phone": phone || "",
        "address1": streetAddress || "N/A",
        "city": city || "Kuala Lumpur",
        "province": state || "",
        "country": country || "Malaysia",
        "zip": postalCode || ""
      },
      "shipping_address": {
        "first_name": name || "Customer",
        "last_name": "",
        "phone": phone || "",
        "address1": streetAddress || "N/A",
        "city": city || "Kuala Lumpur",
        "province": state || "",
        "country": country || "Malaysia",
        "zip": postalCode || ""
      },
      "note": noteText,
      "tags": "On Hold,Google Sheet Import,GHL",
      "financial_status": "pending",
      "send_receipt": false,
      "send_fulfillment_receipt": false,
      "inventory_behaviour": "decrement_obeying_policy"
    }
  };

  if (Object.keys(customerData).length > 0) {
    payload.order.customer = customerData;
  }

  var url = "https://" + store + "/admin/api/2025-01/orders.json";
  var options = {
    "method": "post",
    "headers": {
      "X-Shopify-Access-Token": token,
      "Content-Type": "application/json"
    },
    "payload": JSON.stringify(payload),
    "muteHttpExceptions": true
  };

  var response = UrlFetchApp.fetch(url, options);
  var responseCode = response.getResponseCode();
  var data = JSON.parse(response.getContentText());

  if (responseCode >= 200 && responseCode < 300 && data.order) {
    var resultMsg = "Order Created: " + data.order.id + " (RM" + totalOrderValue + ")";
    if (goldenCard) resultMsg += " | Golden Card: " + goldenCard;
    if (totalOrderValue >= 2000) resultMsg += " | +带财款+4 Coins";
    else if (totalOrderValue >= 1500) resultMsg += " | +吸金款+3 Coins";
    else if (totalOrderValue >= 800) resultMsg += " | +2 Coins";
    sheet.getRange(row, 16).setValue(resultMsg);
  } else {
    var errorMsg = "Error (" + responseCode + "): ";
    if (data.errors) {
      errorMsg += JSON.stringify(data.errors);
    } else {
      errorMsg += response.getContentText();
    }
    sheet.getRange(row, 16).setValue(errorMsg);
  }
}

function QIMEN(birthday, hour, minute) {
  const date = parseFlexibleBirthday(birthday);
  if (!date) return "Invalid date format";
  
  const year = date.getFullYear();
  const month = date.getMonth() + 1;
  const day = date.getDate();

  const calculator = new QiMenDunJiaCalculator();
  const r = calculator.calculateQiMen(year, month, day, hour || 0, minute || 0);
  return `遁甲:${r.basicInfo.dunJia}, 局数:${r.juShu}, 值符:${r.zhiFuZhiShi.zhiFu}, 黄金卡:${r.goldCard}`;
}

function QIMEN_ANALYSIS(birthday, hour, minute) {
  const date = parseFlexibleBirthday(birthday);
  if (!date) return JSON.stringify({ error: "Invalid date format" });
  
  const year = date.getFullYear();
  const month = date.getMonth() + 1;
  const day = date.getDate();

  const calculator = new QiMenDunJiaCalculator();
  const r = calculator.calculateQiMen(year, month, day, hour || 0, minute || 0);
  return JSON.stringify(r);
}
