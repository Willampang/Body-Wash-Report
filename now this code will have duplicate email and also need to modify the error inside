make this code will have avoid duplicate sending email and also make when the form data submit it will direct go inside my sheet no need use form response 1 or 2 etc 
and also this will be just now error i have run one time 
离宫: Failed - Failed to begin order edit: [{"field":null,"message":"The order cannot be edited."}] | 乾宫: Failed - Failed to begin order edit: [{"field":null,"message":"The order cannot be edited."}]
may i know is the free trial version so the api cant edit the order ?thx
// ===== CONFIGURATION =====
const CONFIG = {
  SHOPIFY_STORE: 'raqmux-b1.myshopify.com',
  ACCESS_TOKEN: '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',
  API_VERSION: '2024-01',
  EMAIL_TEMPLATE: {
    subject: '请填写出生信息 - Birth Information Required',
    fromName: 'Mandarin by Louis Loh'
  },
  WALLET_TRIGGERS: ['富豪款', '丰盛款', '吸金款', '带财款', '聚财款']
};

// Golden card product variants for adding to orders
const GOLDEN_CARD_VARIANTS = {
  "乾宫": { variant_id: 51339662229803, price: "0.00", title: "乾宫" },
  "坎宫": { variant_id: 51339662197035, price: "0.00", title: "坎宫" },
  "艮宫": { variant_id: 51339662164267, price: "0.00", title: "艮宫" },
  "震宫": { variant_id: 51339662131499, price: "0.00", title: "震宫" },
  "巽宫": { variant_id: 47263613812888, price: "0.00", title: "巽宫" },
  "离宫": { variant_id: 51339662065963, price: "0.00", title: "离宫" },
  "坤宫": { variant_id: 51339662000427, price: "0.00", title: "坤宫" },
  "兑宫": { variant_id: 51339661934891, price: "0.00", title: "兑宫" }
};

// ===== QIMEN DUNJIA CALCULATOR =====
class QiMenDunJiaCalculator {
  constructor() {
    this.tianGan = ['甲','乙','丙','丁','戊','己','庚','辛','壬','癸'];
    this.diZhi = ['子','丑','寅','卯','辰','巳','午','未','申','酉','戌','亥'];
    this.baMen = ['休门','死门','伤门','杜门','中宫','开门','惊门','生门','景门'];
    this.jiuXing = ['天蓬','天芮','天冲','天辅','天禽','天心','天柱','天任','天英'];
    this.jiuShen = ['直符','螣蛇','太阴','六合','白虎','玄武','九地','九天','太常'];
    this.jiuGong = ['乾六宫','坎一宫','艮八宫','震三宫','中五宫','兑七宫','巽四宫','离九宫','坤二宫'];
    this.jieQiJuShu = {
      '冬至':1,'小寒':1,'大寒':1,'立春':2,'雨水':2,'惊蛰':2,'春分':3,'清明':3,'谷雨':3,
      '立夏':4,'小满':4,'芒种':4,'夏至':5,'小暑':5,'大暑':5,'立秋':6,'处暑':6,'白露':6,
      '秋分':7,'寒露':7,'霜降':7,'立冬':8,'小雪':8,'大雪':8
    };
    this.goldCardMap = {
      "乾": "乾宫","坎": "坎宫","艮": "艮宫","震": "震宫",
      "巽": "巽宫","离": "离宫","坤": "坤宫","兑": "兑宫"
    };
  }

  calculateQiMen(year, month, day, hour, minute = 0) {
    try {
      if (!this.isValidDate(year, month, day)) throw new Error(`Invalid date: ${year}-${month}-${day}`);
      const basicInfo = this.getBasicInfo(year, month, day, hour, minute);
      const juShu = this.getJuShu(basicInfo.jieQi, basicInfo.isYangDun);
      const zhiFuZhiShi = this.getZhiFuZhiShi(basicInfo.jiaZi, juShu);
      const jiuGongJu = this.arrangeJiuGong(juShu, zhiFuZhiShi);
      const goldCard = this.getGoldCard(jiuGongJu);
      return { goldCard: goldCard };
    } catch (error) {
      return { goldCard: null, error: error.message };
    }
  }

  isValidDate(year, month, day) {
    if (year < 1900 || year > 2100) return false;
    if (month < 1 || month > 12) return false;
    if (day < 1 || day > 31) return false;
    const date = new Date(year, month - 1, day);
    return date.getFullYear() === year && date.getMonth() === month - 1 && date.getDate() === day;
  }

  getBasicInfo(year, month, day, hour, minute) {
    const date = new Date(year, month - 1, day, hour, minute);
    const jieQi = this.getJieQi(month, day);
    const isYangDun = this.isYangDun(jieQi);
    const jiaZi = this.getJiaZi(year, month, day, hour);
    return { date, jieQi, isYangDun, jiaZi };
  }

  getJiaZi(year, month, day, hour) {
    const baseDate = new Date(1900, 0, 31);
    const currentDate = new Date(year, month - 1, day);
    const daysDiff = Math.floor((currentDate.getTime() - baseDate.getTime()) / (1000 * 60 * 60 * 24));
    const chineseHour = Math.floor((hour + 1) / 2) % 12;
    const totalUnits = daysDiff * 12 + chineseHour;
    return ((totalUnits % 60) + 60) % 60;
  }

  getJieQi(month, day) {
    const jieQiMap = {
      1: day < 20 ? '小寒' : '大寒', 2: day < 19 ? '大寒' : '立春',
      3: day < 21 ? '惊蛰' : '春分', 4: day < 20 ? '清明' : '谷雨',
      5: day < 21 ? '立夏' : '小满', 6: day < 21 ? '芒种' : '夏至',
      7: day < 23 ? '小暑' : '大暑', 8: day < 23 ? '立秋' : '处暑',
      9: day < 23 ? '白露' : '秋分', 10: day < 23 ? '寒露' : '霜降',
      11: day < 22 ? '立冬' : '小雪', 12: day < 22 ? '大雪' : '冬至'
    };
    return jieQiMap[month] || '春分';
  }

  isYangDun(jieQi) {
    return ['冬至','小寒','大寒','立春','雨水','惊蛰','春分','清明','谷雨'].includes(jieQi);
  }

  getJuShu(jieQi, isYangDun) {
    let ju = this.jieQiJuShu[jieQi] || 1;
    return isYangDun ? ju : (9 - ju + 1);
  }

  getZhiFuZhiShi(jiaZi, juShu) {
    return { 
      zhiFu: this.jiuShen[jiaZi % this.jiuShen.length], 
      zhiShi: this.baMen[jiaZi % this.baMen.length] 
    };
  }

  arrangeJiuGong(juShu) {
    return this.jiuGong.map((gong, i) => {
      const gongName = this.extractGongName(gong);
      return {
        gongWei: gong,
        men: this.baMen[(i + juShu - 1) % this.baMen.length],
        xing: this.jiuXing[(i + juShu - 1) % this.jiuXing.length],
        shen: this.jiuShen[(i + juShu - 1) % this.jiuShen.length],
        gongName: gongName,
        goldCard: this.goldCardMap[gongName] || ""
      };
    });
  }

  extractGongName(gong) {
    const map = { '乾六宫':'乾','坎一宫':'坎','艮八宫':'艮','震三宫':'震','中五宫':'中','兑七宫':'兑','巽四宫':'巽','离九宫':'离','坤二宫':'坤' };
    return map[gong] || gong.charAt(0);
  }

  getGoldCard(jiuGongJu) {
    const zhiFuGong = jiuGongJu.find(g => g.shen === "直符");
    return zhiFuGong ? zhiFuGong.goldCard : null;
  }
}

// ===== HELPER FUNCTIONS =====
function parseTimeInput(birthHour) {
  if (!birthHour) return { hour: 0, minute: 0 };
  
  try {
    const hourStr = String(birthHour).trim();
    let h = 0, m = 0;

    if (hourStr.match(/^\d{1,2}:\d{2}:\d{2}$/)) {
      const parts = hourStr.split(":");
      h = parseInt(parts[0], 10) || 0;
      m = parseInt(parts[1], 10) || 0;
      return { hour: Math.max(0, Math.min(23, h)), minute: Math.max(0, Math.min(59, m)) };
    }

    if (hourStr.match(/^\d{1,2}:\d{2}$/)) {
      const parts = hourStr.split(":");
      h = parseInt(parts[0], 10) || 0;
      m = parseInt(parts[1], 10) || 0;
      return { hour: Math.max(0, Math.min(23, h)), minute: Math.max(0, Math.min(59, m)) };
    }

    if (hourStr.match(/^\d{1,2}$/)) {
      h = parseInt(hourStr, 10) || 0;
      return { hour: Math.max(0, Math.min(23, h)), minute: 0 };
    }

    let isPM = /pm|下午/i.test(hourStr);
    let isAM = /am|上午/i.test(hourStr);
    const cleanHour = hourStr.replace(/[apm\.上下午\s]/gi, '');
    h = parseInt(cleanHour, 10) || 0;
    
    if (isPM && h < 12) h += 12;
    if (isAM && h === 12) h = 0;

    return { hour: Math.max(0, Math.min(23, h)), minute: 0 };
  } catch (error) {
    return { hour: 0, minute: 0 };
  }
}

function parseFlexibleBirthday(birthdayInput) {
  if (!birthdayInput) return null;
  
  try {
    if (birthdayInput instanceof Date) return birthdayInput;
    
    const dateStr = String(birthdayInput).trim();

    const ddmmyyyyMatch = dateStr.match(/^(\d{1,2})[\/\-\.](\d{1,2})[\/\-\.](\d{4})$/);
    if (ddmmyyyyMatch) {
      const day = parseInt(ddmmyyyyMatch[1], 10);
      const month = parseInt(ddmmyyyyMatch[2], 10);
      const year = parseInt(ddmmyyyyMatch[3], 10);
      
      if (year < 1900 || year > 2100 || month < 1 || month > 12 || day < 1 || day > 31) {
        return null;
      }
      
      const date = new Date(year, month - 1, day);
      if (date.getFullYear() !== year || date.getMonth() !== month - 1 || date.getDate() !== day) {
        return null;
      }
      
      return date;
    }

    const yyyymmddMatch = dateStr.match(/^(\d{4})[\/\-\.](\d{1,2})[\/\-\.](\d{1,2})$/);
    if (yyyymmddMatch) {
      const year = parseInt(yyyymmddMatch[1], 10);
      const month = parseInt(yyyymmddMatch[2], 10);
      const day = parseInt(yyyymmddMatch[3], 10);
      
      if (year < 1900 || year > 2100 || month < 1 || month > 12 || day < 1 || day > 31) {
        return null;
      }
      
      const date = new Date(year, month - 1, day);
      if (date.getFullYear() !== year || date.getMonth() !== month - 1 || date.getDate() !== day) {
        return null;
      }
      
      return date;
    }

    return null;
    
  } catch (error) {
    return null;
  }
}

function calculateQimenForBirthday(birthday, birthHour) {
  const date = parseFlexibleBirthday(birthday);
  if (!date) return null;
  
  const timeResult = parseTimeInput(birthHour);
  const h = timeResult.hour;
  const m = timeResult.minute;
  
  try {
    const calc = new QiMenDunJiaCalculator();
    const result = calc.calculateQiMen(
      date.getFullYear(), 
      date.getMonth() + 1, 
      date.getDate(), 
      h, 
      m
    );
    
    return result.goldCard;
  } catch (error) {
    return null;
  }
}

// ===== SHOPIFY HELPER FUNCTIONS =====
function getOrderIdFromName(orderName) {
  try {
    const cleanName = orderName.replace('#', '').trim();
    
    const searchUrl = `https://${CONFIG.SHOPIFY_STORE}/admin/api/${CONFIG.API_VERSION}/orders.json?name=${encodeURIComponent(cleanName)}&status=any&limit=1`;
    const options = {
      method: 'GET',
      headers: {
        'X-Shopify-Access-Token': CONFIG.ACCESS_TOKEN,
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      muteHttpExceptions: true
    };
    
    const resp = UrlFetchApp.fetch(searchUrl, options);
    if (resp.getResponseCode() !== 200) {
      return null;
    }
    
    const orders = JSON.parse(resp.getContentText()).orders;
    return orders && orders.length > 0 ? orders[0].id : null;
  } catch (e) {
    Logger.log(`Error getting order ID: ${e.toString()}`);
    return null;
  }
}

function addGoldenCardToOrder(orderId, goldenCard) {
  const variantInfo = GOLDEN_CARD_VARIANTS[goldenCard];
  if (!variantInfo) {
    return { success: false, error: "Unknown golden card: " + goldenCard };
  }
  
  try {
    // Convert order name to order ID if needed
    let numericOrderId = orderId;
    if (isNaN(orderId) || orderId.toString().match(/[A-Za-z#]/)) {
      numericOrderId = getOrderIdFromName(orderId);
      if (!numericOrderId) {
        return { success: false, error: `Could not find order with name: ${orderId}` };
      }
    }
    
    // Get order details
    const getOrderUrl = `https://${CONFIG.SHOPIFY_STORE}/admin/api/${CONFIG.API_VERSION}/orders/${numericOrderId}.json`;
    const getOptions = {
      method: 'GET',
      headers: {
        'X-Shopify-Access-Token': CONFIG.ACCESS_TOKEN,
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      muteHttpExceptions: true
    };
    
    const getResp = UrlFetchApp.fetch(getOrderUrl, getOptions);
    if (getResp.getResponseCode() !== 200) {
      return { success: false, error: "Could not fetch order details: " + getResp.getContentText() };
    }
    
    const order = JSON.parse(getResp.getContentText()).order;
    
    // Check if already has this golden card
    const existingGoldenCard = order.line_items.find(item => 
      item.variant_id === parseInt(variantInfo.variant_id)
    );
    
    if (existingGoldenCard) {
      return { 
        success: true, 
        skipped: true,
        orderName: order.name,
        response: `Order ${order.name} already has ${goldenCard}` 
      };
    }
    
    // Use GraphQL API for order editing
    const graphqlUrl = `https://${CONFIG.SHOPIFY_STORE}/admin/api/${CONFIG.API_VERSION}/graphql.json`;
    
    // Step 1: Begin order edit
    const beginEditMutation = `
      mutation orderEditBegin($id: ID!) {
        orderEditBegin(id: $id) {
          calculatedOrder {
            id
          }
          userErrors {
            field
            message
          }
        }
      }
    `;
    
    const beginEditVariables = {
      id: `gid://shopify/Order/${numericOrderId}`
    };
    
    const beginOptions = {
      method: 'POST',
      headers: {
        'X-Shopify-Access-Token': CONFIG.ACCESS_TOKEN,
        'Content-Type': 'application/json'
      },
      payload: JSON.stringify({
        query: beginEditMutation,
        variables: beginEditVariables
      }),
      muteHttpExceptions: true
    };
    
    const beginResp = UrlFetchApp.fetch(graphqlUrl, beginOptions);
    const beginResult = JSON.parse(beginResp.getContentText());
    
    if (beginResult.errors || beginResult.data.orderEditBegin.userErrors.length > 0) {
      const errors = beginResult.errors || beginResult.data.orderEditBegin.userErrors;
      return { success: false, error: `Failed to begin order edit: ${JSON.stringify(errors)}` };
    }
    
    const calculatedOrderId = beginResult.data.orderEditBegin.calculatedOrder.id;
    
    // Step 2: Add line item
    const addItemMutation = `
      mutation orderEditAddVariant($id: ID!, $variantId: ID!, $quantity: Int!) {
        orderEditAddVariant(id: $id, variantId: $variantId, quantity: $quantity) {
          calculatedOrder {
            id
          }
          userErrors {
            field
            message
          }
        }
      }
    `;
    
    const addItemVariables = {
      id: calculatedOrderId,
      variantId: `gid://shopify/ProductVariant/${variantInfo.variant_id}`,
      quantity: 1
    };
    
    const addItemOptions = {
      method: 'POST',
      headers: {
        'X-Shopify-Access-Token': CONFIG.ACCESS_TOKEN,
        'Content-Type': 'application/json'
      },
      payload: JSON.stringify({
        query: addItemMutation,
        variables: addItemVariables
      }),
      muteHttpExceptions: true
    };
    
    const addItemResp = UrlFetchApp.fetch(graphqlUrl, addItemOptions);
    const addItemResult = JSON.parse(addItemResp.getContentText());
    
    if (addItemResult.errors || addItemResult.data.orderEditAddVariant.userErrors.length > 0) {
      const errors = addItemResult.errors || addItemResult.data.orderEditAddVariant.userErrors;
      return { success: false, error: `Failed to add line item: ${JSON.stringify(errors)}` };
    }
    
    // Step 3: Commit the edit
    const commitMutation = `
      mutation orderEditCommit($id: ID!, $notifyCustomer: Boolean, $staffNote: String) {
        orderEditCommit(id: $id, notifyCustomer: $notifyCustomer, staffNote: $staffNote) {
          order {
            id
          }
          userErrors {
            field
            message
          }
        }
      }
    `;
    
    const commitVariables = {
      id: calculatedOrderId,
      notifyCustomer: false,
      staffNote: `Golden card ${goldenCard} added automatically based on birth information`
    };
    
    const commitOptions = {
      method: 'POST',
      headers: {
        'X-Shopify-Access-Token': CONFIG.ACCESS_TOKEN,
        'Content-Type': 'application/json'
      },
      payload: JSON.stringify({
        query: commitMutation,
        variables: commitVariables
      }),
      muteHttpExceptions: true
    };
    
    const commitResp = UrlFetchApp.fetch(graphqlUrl, commitOptions);
    const commitResult = JSON.parse(commitResp.getContentText());
    
    if (commitResult.errors || commitResult.data.orderEditCommit.userErrors.length > 0) {
      const errors = commitResult.errors || commitResult.data.orderEditCommit.userErrors;
      return { success: false, error: `Failed to commit order edit: ${JSON.stringify(errors)}` };
    }
    
    return { 
      success: true, 
      orderId: numericOrderId,
      orderName: order.name,
      response: `Order ${order.name} updated with golden card: ${goldenCard}` 
    };
    
  } catch (e) {
    return { success: false, error: e.toString() };
  }
}

// ===== CHECK IF ORDER ALREADY PROCESSED =====
function isOrderProcessed(orderId) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ordersSheet = ss.getSheetByName("Orders");
    
    if (!ordersSheet) return false;
    
    const data = ordersSheet.getDataRange().getValues();
    
    for (let i = 1; i < data.length; i++) {
      if (String(data[i][0]) === String(orderId)) {
        Logger.log(`DUPLICATE: Order ID ${orderId} already exists in row ${i+1}`);
        return true;
      }
    }
    
    return false;
  } catch (e) {
    Logger.log("Error checking duplicate: " + e.toString());
    return false;
  }
}

// ===== CHECK WALLET TYPES =====
function checkWalletTypes(orderData) {
  let totalWalletQty = 0;
  let walletTypes = [];
  
  orderData.line_items.forEach(item => {
    const title = (item.title || '').trim();
    const variant = (item.variant_title || '').trim();
    
    CONFIG.WALLET_TRIGGERS.forEach(walletType => {
      if (title.includes(walletType) || variant.includes(walletType)) {
        totalWalletQty += item.quantity;
        walletTypes.push(`${walletType} x${item.quantity}`);
      }
    });
  });
  
  return {
    hasTriggerWallets: totalWalletQty > 0,
    totalQty: totalWalletQty,
    walletTypes: walletTypes
  };
}

// ===== CREATE FORM WITH DATE & TIME FIELDS =====
function createDynamicForm(orderName, customerName, customerEmail, quantity, walletTypes) {
  try {
    const form = FormApp.create(`Birth Info - ${orderName}`);
    
    form.setTitle(`钱包出生信息表格 Wallet Birth Information Form`);
    
    form.setDescription(
      `===============================================\n` +
      `订单号 Order: ${orderName}\n` +
      `客户 Customer: ${customerName}\n` +
      `邮箱 Email: ${customerEmail}\n` +
      `===============================================\n\n` +
      `您购买的钱包 Wallets Purchased:\n` +
      walletTypes.map(w => `  • ${w}`).join('\n') + `\n\n` +
      `请为 ${quantity} 个钱包填写出生信息\n` +
      `Please fill birth information for ${quantity} wallet(s)\n`
    );
    
    // Auto-filled fields
    form.addTextItem()
      .setTitle('订单号 Order ID (自动填写)')
      .setHelpText('请勿修改 Do not modify')
      .setRequired(true);
    
    form.addTextItem()
      .setTitle('客户邮箱 Customer Email (自动填写)')
      .setHelpText('请勿修改 Do not modify')
      .setRequired(true);
    
    // Create sections for each wallet
    for (let i = 1; i <= quantity; i++) {
      form.addPageBreakItem()
        .setTitle(`钱包 Wallet ${i} / ${quantity}`)
        .setHelpText(`请填写第 ${i} 个钱包使用者的信息`);
      
      form.addTextItem()
        .setTitle(`钱包 ${i} - 姓名 Name`)
        .setHelpText('使用此钱包的人的全名 Full name')
        .setRequired(true);
      
      form.addDateItem()
        .setTitle(`钱包 ${i} - 出生日期 Birthday`)
        .setHelpText('请选择出生日期 Please select birth date')
        .setRequired(true);
      
      form.addTimeItem()
        .setTitle(`钱包 ${i} - 出生时间 Birth Time`)
        .setHelpText('请选择出生时间 (24小时制) Please select birth time (24-hour format)')
        .setRequired(true);
    }
    
    // Confirmation page
    form.addPageBreakItem()
      .setTitle('确认提交 Confirm & Submit')
      .setHelpText('请检查所有信息后提交 Please review before submitting');
    
    const formId = form.getId();
    const baseUrl = form.getPublishedUrl();
    const items = form.getItems();
    
    // Get entry IDs
    const orderEntryId = items[0].getId();
    const emailEntryId = items[1].getId();
    
    // Create prefill URL
    const prefillUrl = baseUrl + 
      `?entry.${orderEntryId}=${encodeURIComponent(orderName)}` +
      `&entry.${emailEntryId}=${encodeURIComponent(customerEmail)}`;
    
    // Link form to spreadsheet for responses
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    form.setDestination(FormApp.DestinationType.SPREADSHEET, ss.getId());
    
    Logger.log(`Form created: ${formId}`);
    Logger.log(`Prefill URL: ${prefillUrl}`);
    
    return {
      success: true,
      formId: formId,
      formUrl: prefillUrl,
      editUrl: form.getEditUrl()
    };
    
  } catch (e) {
    Logger.log(`Form creation error: ${e.toString()}`);
    return {
      success: false,
      error: e.toString()
    };
  }
}

// ===== SEND EMAIL =====
function sendFormEmail(customerEmail, customerName, formUrl, orderName, walletTypes) {
  try {
    const subject = CONFIG.EMAIL_TEMPLATE.subject;
    
    const body = `
亲爱的 ${customerName},

感谢您的购买!

订单号 Order: ${orderName}

您购买的钱包 Wallets purchased:
${walletTypes.map(w => `  • ${w}`).join('\n')}

请点击以下链接填写出生信息表格:
Please click the link below to fill the form:

${formUrl}

此信息将用于计算您的专属金卡(基于奇门遁甲).
This information will be used to calculate your personalized golden cards.

如有疑问请联系客服.
For questions please contact customer service.

此致,
${CONFIG.EMAIL_TEMPLATE.fromName}

---
此邮件由系统自动发送
This email is sent automatically
    `.trim();
    
    MailApp.sendEmail({
      to: customerEmail,
      subject: subject,
      body: body,
      name: CONFIG.EMAIL_TEMPLATE.fromName
    });
    
    Logger.log(`Email sent to: ${customerEmail}`);
    return { success: true };
    
  } catch (e) {
    Logger.log(`Email error: ${e.toString()}`);
    return { success: false, error: e.toString() };
  }
}

// ===== PROCESS ORDER =====
function processNewOrder(orderData) {
  try {
    const orderId = orderData.id;
    const orderName = orderData.name || orderData.order_number || `#${orderId}`;
    
    let customerName = "Customer";
    if (orderData.customer) {
      const firstName = orderData.customer.first_name || "";
      const lastName = orderData.customer.last_name || "";
      customerName = `${firstName} ${lastName}`.trim() || orderData.customer.email || "Customer";
    }
    
    const email = orderData.customer ? orderData.customer.email : "";
    
    if (!email) {
      Logger.log(`ERROR: No email for order ${orderName}`);
      return { success: false, error: "No customer email" };
    }
    
    Logger.log(`Processing: ${orderName} - ${customerName} (${email})`);
    
    // CHECK DUPLICATE
    if (isOrderProcessed(orderId)) {
      Logger.log(`DUPLICATE: Order ${orderName} already processed`);
      return { 
        success: false, 
        error: "Duplicate - already processed",
        duplicate: true
      };
    }
    
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    let ordersSheet = ss.getSheetByName("Orders");
    
    if (!ordersSheet) {
      ordersSheet = ss.insertSheet("Orders");
      ordersSheet.appendRow([
        "Order ID", "Order Name", "Customer Name", "Email", 
        "Wallet Types", "Qty", "Form URL", "Form Sent", "Status", "Golden Cards", "Timestamp"
      ]);
      const headerRange = ordersSheet.getRange(1, 1, 1, 11);
      headerRange.setFontWeight("bold");
      headerRange.setBackground("#4285f4");
      headerRange.setFontColor("#ffffff");
    }
    
    const walletCheck = checkWalletTypes(orderData);
    
    if (!walletCheck.hasTriggerWallets) {
      Logger.log(`SKIPPED: No trigger wallets in ${orderName}`);
      return { 
        success: false, 
        error: "No trigger wallets",
        skipped: true 
      };
    }
    
    const formResult = createDynamicForm(
      orderName, 
      customerName, 
      email, 
      walletCheck.totalQty,
      walletCheck.walletTypes
    );
    
    if (!formResult.success) {
      return { success: false, error: "Form creation failed: " + formResult.error };
    }
    
    const emailResult = sendFormEmail(
      email, 
      customerName, 
      formResult.formUrl, 
      orderName,
      walletCheck.walletTypes
    );
    
    ordersSheet.appendRow([
      orderId,
      orderName,
      customerName,
      email,
      walletCheck.walletTypes.join(' | '),
      walletCheck.totalQty,
      formResult.formUrl,
      emailResult.success ? "YES" : "FAILED",
      "Pending Form Submission",
      "",
      new Date()
    ]);
    
    Logger.log(`SUCCESS: ${orderName} processed`);
    
    return {
      success: true,
      orderName: orderName,
      formUrl: formResult.formUrl,
      emailSent: emailResult.success
    };
    
  } catch (e) {
    Logger.log(`ERROR: ${e.toString()}`);
    return { success: false, error: e.toString() };
  }
}

// ===== WEB APP HANDLERS =====
function doGet(e) {
  return ContentService.createTextOutput(
    JSON.stringify({
      status: "OK",
      message: "Wallet Birth Info System Running",
      timestamp: new Date().toISOString()
    })
  ).setMimeType(ContentService.MimeType.JSON);
}

function doPost(e) {
  try {
    if (!e || !e.postData || !e.postData.contents) {
      return ContentService.createTextOutput(
        JSON.stringify({ success: false, error: "No data" })
      ).setMimeType(ContentService.MimeType.JSON);
    }
    
    const orderData = JSON.parse(e.postData.contents);
    const result = processNewOrder(orderData);
    
    return ContentService.createTextOutput(
      JSON.stringify(result)
    ).setMimeType(ContentService.MimeType.JSON);
    
  } catch (error) {
    return ContentService.createTextOutput(
      JSON.stringify({ success: false, error: error.toString() })
    ).setMimeType(ContentService.MimeType.JSON);
  }
}

// ===== FORM SUBMISSION HANDLER (ENHANCED WITH SHOPIFY ORDER EDITING) =====
function onFormSubmit(e) {
  try {
    Logger.log("Form submitted - processing...");
    
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    let responsesSheet = ss.getSheetByName("Form Responses");
    
    if (!responsesSheet) {
      responsesSheet = ss.insertSheet("Form Responses");
      responsesSheet.appendRow([
        "Submission Time", "Order ID", "Email", "Names", "Birthdays", "Birth Times", 
        "Golden Cards", "Card Summary", "Shopify Update Status"
      ]);
      const headerRange = responsesSheet.getRange(1, 1, 1, 9);
      headerRange.setFontWeight("bold");
      headerRange.setBackground("#34a853");
      headerRange.setFontColor("#ffffff");
    }
    
    const responses = e.values;
    const submissionTime = responses[0] || new Date();
    const orderName = responses[1] || "";
    const email = responses[2] || "";
    
    Logger.log(`Processing form for: ${orderName}`);
    
    // Parse wallet data - starts from index 3
    // Pattern: Name, Date, Time for each wallet
    const walletData = [];
    let i = 3;
    while (i + 2 < responses.length) {
      const name = responses[i];
      const birthday = responses[i + 1];
      const birthTime = responses[i + 2];
      
      if (name && birthday && birthTime) {
        // Convert date object to string if needed
        let birthdayStr = birthday;
        if (birthday instanceof Date) {
          birthdayStr = `${birthday.getDate()}/${birthday.getMonth()+1}/${birthday.getFullYear()}`;
        }
        
        // Convert time to HH:MM format
        let birthTimeStr = birthTime;
        if (birthTime instanceof Date) {
          birthTimeStr = `${birthTime.getHours()}:${String(birthTime.getMinutes()).padStart(2, '0')}`;
        }
        
        walletData.push({
          name: name,
          birthday: birthdayStr,
          birthTime: birthTimeStr
        });
      }
      i += 3;
    }
    
    if (walletData.length === 0) {
      Logger.log(`ERROR: No wallet data found`);
      responsesSheet.appendRow([
        submissionTime, orderName, email, "ERROR", "", "", "", "No data found", "N/A"
      ]);
      return;
    }
    
    // Calculate golden cards
    const goldenCards = [];
    const names = [];
    const birthdays = [];
    const birthTimes = [];
    
    walletData.forEach(wallet => {
      names.push(wallet.name);
      birthdays.push(wallet.birthday);
      birthTimes.push(wallet.birthTime);
      
      const goldCard = calculateQimenForBirthday(wallet.birthday, wallet.birthTime);
      goldenCards.push(goldCard || "ERROR");
      
      Logger.log(`${wallet.name}: ${goldCard || "CALC ERROR"}`);
    });
    
    // Count cards
    const cardCounts = {};
    goldenCards.forEach(card => {
      if (card && card !== "ERROR") {
        cardCounts[card] = (cardCounts[card] || 0) + 1;
      }
    });
    
    const cardSummary = Object.entries(cardCounts)
      .map(([card, count]) => `${card}:${count}`)
      .join(' | ') || "No cards calculated";
    
    // ===== NEW: ADD GOLDEN CARDS TO SHOPIFY ORDER =====
    let shopifyUpdateStatus = "Not attempted";
    
    if (orderName && goldenCards.length > 0) {
      const shopifyResults = [];
      
      // Add each unique golden card to the order
      const uniqueCards = [...new Set(goldenCards.filter(card => card && card !== "ERROR"))];
      
      for (const card of uniqueCards) {
        const result = addGoldenCardToOrder(orderName, card);
        
        if (result.success) {
          if (result.skipped) {
            shopifyResults.push(`${card}: Already added`);
          } else {
            shopifyResults.push(`${card}: Added successfully`);
          }
        } else {
          shopifyResults.push(`${card}: Failed - ${result.error}`);
        }
        
        // Small delay between API calls
        Utilities.sleep(500);
      }
      
      shopifyUpdateStatus = shopifyResults.join(' | ');
      Logger.log(`Shopify update: ${shopifyUpdateStatus}`);
    } else {
      shopifyUpdateStatus = "No valid cards or order name";
    }
    
    // Save to sheet
    responsesSheet.appendRow([
      submissionTime,
      orderName,
      email,
      names.join(' | '),
      birthdays.join(' | '),
      birthTimes.join(' | '),
      goldenCards.join(' | '),
      cardSummary,
      shopifyUpdateStatus
    ]);
    
    // Update order status
    updateOrderStatus(orderName, "Form Completed - Cards Added to Shopify", cardSummary);
    
    Logger.log(`SUCCESS: ${orderName} - ${cardSummary}`);
    
  } catch (e) {
    Logger.log("Form error: " + e.toString());
    try {
      const ss = SpreadsheetApp.getActiveSpreadsheet();
      const responsesSheet = ss.getSheetByName("Form Responses");
      if (responsesSheet) {
        responsesSheet.appendRow([
          new Date(), "SYSTEM ERROR", "", "", "", "", "", 
          "Error: " + e.toString(), "Failed"
        ]);
      }
    } catch (logError) {
      Logger.log("Failed to log error: " + logError.toString());
    }
  }
}

// ===== UPDATE ORDER STATUS =====
function updateOrderStatus(orderName, status, goldenCards) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const ordersSheet = ss.getSheetByName("Orders");
    
    if (!ordersSheet) {
      Logger.log("Orders sheet not found");
      return;
    }
    
    const data = ordersSheet.getDataRange().getValues();
    
    for (let i = 1; i < data.length; i++) {
      if (data[i][1] === orderName) {
        ordersSheet.getRange(i + 1, 9).setValue(status);
        ordersSheet.getRange(i + 1, 10).setValue(goldenCards);
        Logger.log(`Updated: ${orderName} - ${status}`);
        break;
      }
    }
  } catch (e) {
    Logger.log("Update status error: " + e.toString());
  }
}

// ===== SETUP FORM TRIGGER (RUN THIS ONCE) =====
function setupFormTrigger() {
  // Delete existing triggers first
  const triggers = ScriptApp.getProjectTriggers();
  triggers.forEach(trigger => {
    if (trigger.getHandlerFunction() === 'onFormSubmit') {
      ScriptApp.deleteTrigger(trigger);
    }
  });
  
  // Create new trigger for form submissions
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  ScriptApp.newTrigger('onFormSubmit')
    .forSpreadsheet(ss)
    .onFormSubmit()
    .create();
  
  Logger.log("Form trigger setup complete!");
  return "Trigger created successfully";
}
